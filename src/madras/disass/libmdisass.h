/*
   Copyright (C) 2004 - 2018 Universit√© de Versailles Saint-Quentin-en-Yvelines (UVSQ)

   This file is part of MAQAO.

  MAQAO is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
   as published by the Free Software Foundation; either version 3
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef LIBMDISASS_H_
#define LIBMDISASS_H_
/**
 * \file libmdisass.h
 * \brief Libmdisass is a multi-architecture disassembler library, using source files 
 * generated by the MINJAG generator to handle architecture-specific file.
 *
 * \page disass_main Disassembler documentation page
 * \brief Description of the disassembler global behaviour
 *
 * \section general General description
 * The functions from \e libmdisass allow to parse a binary ELF file and disassemble its code.
 * This is done by the \ref asmfile_disassemble function.
 * The function takes as input a \ref asmfile_t structure containing the name of the file.
 * The file will be parsed if necessary, then disassembled.
 * The \ref asmfile_t structure will then be filled with all informations retrieved from the disassembly:
 * - List of the assembly instructions contained in the file, including destinations of direct branches
 * - List of labels
 * - Table of direct branches in the file, indexed by the destination addresses of the branch
 *
 * The library is also able to parse a static library file (archive), using \ref asmfile_disassemble_n.
 * In that case, an array of \ref asmfile_t structures will be returned, each of them containing the result
 * of the disassembly of one of the object files contained in the archive.
 *
 * \section elfparse ELF parsing
 * Libmdisass is able to process files that have been already parsed or not. If the file has not already been parsed,
 * the ELF parser will be invoked.
 *
 * The parsing of the ELF file is performed using the functions defined in \e limbtroll.
 * See the documentation of this module for a more detailed description.
 *
 * Upon parsing an ELF file, the \ref asmfile_t structure will be updated to contain a pointer to the
 * structure used by \e libmtroll to store the parsed file, along with a pointer to the function for freeing it
 * (this will be used when freeing the \ref asmfile_t structure). The structure will also be annotated
 * to indicate that the file has been parsed.
 *
 * \subsection Labels
 *
 * All the labels retrieved from the binary file will be loaded into the \ref asmfile_t structure.
 * Their type is updated by the libtroll to specify if they are identified as corresponding to a function by the ELF or DWARF
 * informations, or if they where added by the patcher.
 * Labels are stored inside a hashtable indexed on the address of the label and in a list ordered by the increasing address of the labels.
 * The ordering of the list breaks ties on address by ensuring that labels eligible to be associated to an instruction will
 * appear first (see \ref disasslbls for the definition of eligible labels).
 *
 * \section disass Disassembly
 *
 * The disassembly is performed through a linear sweep algorithm: the file is sequentially disassembled. 
 * The disassembly is performed on all sections of the ELF file containing executable code
 * (as identified by the function \ref elffile_scnisprog).
 *
 * The disassembler uses a LR(0) parser coded as a finite state machine (FSM). The finite state machine 
 * relies on tables describing the states and transitions to use depending on the architecture of the 
 * file to disassemble. These tables and the associated functions are generated by MINJAG.
 *
 * The inner workings of the FSM are described in \ref disass_fsmdesc.
 *
 * \subsection disassinit Disassembler initialisation
 * At the beginning of a disassembly session, the disassembler initialises the FSM context (stored in 
 * a \ref fsmcontext_t structure). It then retrieves the architecture for which the file to disassemble
 * is compiled and uses this to load the respective disassembly tables and functions into the FSM context.
 * An error is raised if the file is not compiled for a recognised architecture.
 *
 * \subsection disassexe Disassembler execution
 * The disassembler loads the bytes of each section of the ELF file containing executable code and invokes 
 * the FSM parser on the retrieved stream. The parser will return an \ref insn_t structure containing
 * the opcode and operands.
 *
 * For each instruction parsed, the following operations will be performed:
 * - Updating the virtual address of the instruction
 * - Updating the coding of the instruction from the FSM context
 * - A label is associated to the instruction (see \ref disasslbls for the rules on associating labels)
 *  - If a label of type function points to an address in the middle of a disassembled instruction, the instruction
 * is considered as badly disassembled. It is truncated up to the address of the label and marked as bad, then the parsing
 * is reset to the address of the label.
 * - If there was no parsing error, the branch table is updated if necessary (if the instruction is a branch, 
 *     it is added with the address of its destination as an index).
 * - The instructions is annotated depending on the section being disassembled.
 * - The instruction is added to the list of disassembled instructions.
 *
 * \subsection disasslbls Associating labels to instructions
 *
 * All instructions are associated to a label, which is the last eligible label encountered. If a label has the same
 * address as an instruction associated to it, the label is updated as well to point to this instruction.
 *
 * An eligible label is defined according to the following rules:
 * - It is not of type "dummy". A "dummy" label will however be updated to point at the instruction
 * - It does not begin with a '.' character
 * - If more than one label is associated to the instruction's address, the label of type function will be eligible.
 *  - If more than one label of type function is present at a given address or if no labels of type function are present but
 * multiple labels are defined, one of the possible labels will be eligible (usually the last one to appear in the ELF file).
 *
 * \subsection disassend Disassembler completion
 * When all sections have been disassembled, the instruction list is scanned once more.
 * - Instructions referencing an address in the ELF file that is not an instruction are added to the table of targets
 *     in the \ref elffile_t structure containing the parsed file.
 * - Instructions whose address is present in the table of branches are set as branch targets for the instructions 
 *     branching to this address.
 *
 * All intermediate structures used are then freed and the \ref asmfile_t structure is annotated to indicate that it
 * has been disassembled.
 *
 * \subsection disassraw Raw disassembly
 *
 * The raw disassembly mode is mainly intended for tests of the disassembler performances. It skips the parsing of the file
 * and only attempts to disassemble all or a part of the binary file against a given architecture.
 *
 * \subpage disass_fsmdesc
 *
 * \subpage disass_x86_64_macros
 *
 * \subpage disass_k1om_macros
 * */

#include "libmasm.h"
#include "fsmutils.h"

/**
 * Definitions of the options for the asmfile_disassemble_n function
 * */
//#define DISASSEMBLY_FULL 		  0x00000001  /**<Full disassembly must occur*/
//#define DISASSEMBLY_PARSEONLY	  0x00000002  /**<The binary file will be parsed but not disassembled*/
//#define DISASSEMBLY_NODEBUG     0x00000004  /**<The debug data must not be retrieved*/
//#define DISASSEMBLY_FROMARCHIVE 0x10000000  /**<The file comes from an archive*/
/**\todo TODO (2015-03-09) BUG! Some of those names are also defined in libmasm.h, and with different values. This leads to the
 * disassembly to ignore some options. Choose one header where to define those and stick to it*/

/**
 * Disassembles a stream of bytes into a list of instructions
 * \param af Structure containing the resulting list of instructions
 * \param stream The stream
 * \param len The size in bytes of the stream
 * \param startaddr Address of the first instruction in the stream
 * \param arch Structure containing the architecture for which the stream is to be disassembled
 * \param archname Name of the architecture. Will be used if \c arch is NULL
 * \return EXIT_SUCCESS if the stream could be successfully disassembled, error code otherwise
 * */
extern int stream_disassemble(asmfile_t* af, unsigned char* stream,
      uint64_t len, int64_t startaddr, arch_t* arch, char* archname);

/**
 * Performs a raw disassembly of a file whose name is contained into an asmfile structure
 * The raw content of the file will be disassembled without any preliminary parsing of the file. This function
 * is mainly intended for allowing comparisons with other disassemblers or to disassemble a file containing the
 * extracted binary code of another. Use with caution, especially for the
 * \param af A pointer to the structure holding the ASM file. It must contain the name of the file to disassemble
 * If the disassembly is successful, it will contain the instructions from the disassembled file
 * \param offset The offset at which to start disassembly in the file
 * \param len The number of bytes to disassemble in the file
 * \param startaddr Address associated to the first instruction
 * \param archname Name of the architecture the file is defined in
 * \return EXIT_SUCCESS if the file could be successfully disassembled, error code otherwise
 * */
extern int asmfile_disassemble_raw(asmfile_t* af, uint64_t offset, uint64_t len,
      int64_t startaddr, char* archname);

/**
 * Performs a disassembly of the instructions in a file already containing instructions and their coding,
 * and update the existing structures with the informations from the disassembly
 * \param af Asmfile
 * \return EXIT_SUCCESS / error code
 * */
extern int asmfile_disassemble_existing(asmfile_t* af);

/**
 * Disassembles a file whose name is contained into an asmfile structure
 * \param af A pointer to the structure holding the ASM file. It must contain the name of the file to disassemble.
 * If the file has not already been parsed (by invoking asmfile_parse) it will be at this point
 * If the disassembly is successful, it will contain the instructions from the disassembled file, the label hashtables, and
 * a pointer to the object containing the disassembled file
 * \param options Options for disassembly
 * \return EXIT_SUCCESS if the file could be successfully disassembled, error code otherwise
 * */
extern int asmfile_disassemble(asmfile_t* af);

/**
 * Disassembles a file containing potentially multiple files (it is the case for archives) and returns an asmfile for each of them
 * \param af Empty structure containing the name of the file to disassemble
 * \param afiles Return parameter. Will contain an array of asmfile structures corresponding to the disassembly of each member found in the file, or
 * point to NULL if the file is not an archive
 * \param options Options for disassembly
 * \param filedesc Descriptor of the file to disassemble. If strictly positive, will override the name of the file contained in \c af and disassemble
 * the file with this descriptor instead. Otherwise it will be ignored.
 * \return
 * - 0 if the file was not an archive and was successfully disassembled
 * - The size of the \e afiles array if it was and archive and was successfully disassembled
 * - Negative value if an error occurred.
 * */
extern int asmfile_disassemble_n(asmfile_t* af, asmfile_t*** afiles,
      int options, int filedesc);

/**
 * Frees all members in an asmfile_t structure that were updated in the asmfile_disassemble function
 * \param a The asmfile_t structure holding the disassembled file. After execution, all members will be freed and set to 0
 * */
extern void asmfile_disassembled_free(void* a);

/**
 * Error handler for the disassembler that will be invoked whenever a parsing error occurs.
 * It sets the current instruction's opcode as "bad"
 * \param fc Pointer to the structure containing the FSM context
 * \param i Pointer to the address of the instruction being parsed
 * \param a Pointer to the asmfile_t where the result of disassembly is being stored
 * */
extern void error_handler(fsmcontext_t* fc, void** i, void* a);

#endif /*LIBMDISASS_H_*/

