/*
   Copyright (C) 2004 - 2018 Universit√© de Versailles Saint-Quentin-en-Yvelines (UVSQ)

   This file is part of MAQAO.

  MAQAO is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
   as published by the Free Software Foundation; either version 3
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
#ifndef ARM64_MACROS_H
#define ARM64_MACROS_H

#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include "libmasm.h"
#include "libmcommon.h"
#include "arm64_arch.h"
#include "arm64_ext.h"

/**
* \file arm64_macros.def
* \brief This file contains the list of macros invoked by semantic actions. It has to be processed by a script to generate a valid header file
* \warning This file has been automatically generated by MINJAG from file arm64_1861b70696e6c6f8e8afb9548a03e936.bdf and should not be modified
* */

static size_t arm_values[] __attribute__((unused)) = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
      32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};

/*Role values*/
#define U_ROLE_UNDEF          OP_ROLE_UNDEF              /**<Alias for undefined role*/
#define U_READ                OP_ROLE_SRC                /**<Alias for source role*/
#define U_WRITE               OP_ROLE_DST                /**<Alias for destination role*/
#define U_READ_WRITE          (OP_ROLE_SRC|OP_ROLE_DST)  /**<Alias for source+destination role*/

#define U_A_JCOND             (A_CONDITIONAL|A_JUMP)

//TODO Handle fixed point type
#define T_UFXP                T_UINT
#define T_SFXP                T_SINT

#define DATASZ_VAR            42

#define DATASZ_STD            DATASZ_32b
#define DATASZ_CPC            DATASZ_32b
#define DATASZ_SPECIAL        DATASZ_32b
#define DATASZ_VEC_SINGLE     DATASZ_32b
#define DATASZ_VEC_DOUBLE     DATASZ_64b
#define DATASZ_VEC_QUAD       DATASZ_128b

#define DATASZ_BYTE           DATASZ_8b
#define DATASZ_HWORD          DATASZ_16b
#define DATASZ_SWORD          DATASZ_32b
#define DATASZ_DWORD          DATASZ_64b
#define DATASZ_QWORD          DATASZ_128b

#define U_MSL                 MSL
#define U_LSL                 LSL
#define U_SXTX                SXTX

/* Fixed values */
#define U_ZERO                0
#define U_ONE                 1
#define U_TWO                 2
#define U_THREE               3
#define U_FOUR                4
#define U_FIVE                5
#define U_SEVEN               7
#define U_EIGHT               8
#define U_TWELVE              12
#define U_SIXTEEN             16
#define U_NINETEEN            19
#define U_THIRTYTWO           32

/* Constant values */
#define U_CI0                 0
#define U_CI1                 1
#define U_CI2                 2
#define U_CI3                 3
#define U_CI4                 4
#define U_CI6                 6
#define U_CI8                 8
#define U_CI12                12
#define U_CI16                16
#define U_CI24                24
#define U_CI32                32
#define U_CI48                48
#define U_CI64                64

/* Maximum number of operands in an operand list */
#define U_MAX_LIST_OPRND      4

/* Suffixes */
#define U_SUF_R      0x1      //Operand is read
#define U_SUF_W      0x2      //Operand is write
#define U_SUF_ALL    0x4      //All (read or write) operands are concerned
#define U_SUF_FRST   0x8      //Only the first (read or write) operand is concerned
#define U_SUF_SCND   0x10     //Only the second (read or write) operand is concerned
#define U_SUF_THRD   0x20     //Only the third (read or write) operand is concerned
#define U_SUF_32b    0x40     //32-bits operand
#define U_SUF_64b    0x80     //64-bits operand
#define U_SUF_128b   0x100    //128-bits operand
#define U_SUF_B      0x200    //Operand process bytes
#define U_SUF_H      0x400    //Operand process half-words
#define U_SUF_S      0x800    //Operand process words
#define U_SUF_D      0x1000   //Operand process double-word(s)
#define U_SUF_Q      0x2000   //Operand process quad-word

// Read arrangements
#define U_RB         (U_SUF_R|U_SUF_ALL|U_SUF_B)
#define U_RH         (U_SUF_R|U_SUF_ALL|U_SUF_H)
#define U_RS         (U_SUF_R|U_SUF_ALL|U_SUF_S)
#define U_RD         (U_SUF_R|U_SUF_ALL|U_SUF_D)

#define U_2RH        (U_SUF_R|U_SUF_SCND|U_SUF_H)
#define U_2RS        (U_SUF_R|U_SUF_SCND|U_SUF_S)
#define U_2RD        (U_SUF_R|U_SUF_SCND|U_SUF_D)

#define U_3RH        (U_SUF_R|U_SUF_THRD|U_SUF_H)
#define U_3RS        (U_SUF_R|U_SUF_THRD|U_SUF_S)

// 64-bits variants
#define U_R8B        (U_SUF_R|U_SUF_ALL|U_SUF_B|U_SUF_64b)
#define U_R4H        (U_SUF_R|U_SUF_ALL|U_SUF_H|U_SUF_64b)
#define U_R2S        (U_SUF_R|U_SUF_ALL|U_SUF_S|U_SUF_64b)
#define U_R1D        (U_SUF_R|U_SUF_ALL|U_SUF_D|U_SUF_64b)

#define U_1R8B       (U_SUF_R|U_SUF_FRST|U_SUF_B|U_SUF_64b)
#define U_1R4H       (U_SUF_R|U_SUF_FRST|U_SUF_H|U_SUF_64b)
#define U_1R2S       (U_SUF_R|U_SUF_FRST|U_SUF_S|U_SUF_64b)
#define U_1R1D       (U_SUF_R|U_SUF_FRST|U_SUF_D|U_SUF_64b)

#define U_2R8B       (U_SUF_R|U_SUF_SCND|U_SUF_B|U_SUF_64b)
#define U_2R4H       (U_SUF_R|U_SUF_SCND|U_SUF_H|U_SUF_64b)
#define U_2R2S       (U_SUF_R|U_SUF_SCND|U_SUF_S|U_SUF_64b)
#define U_2R1D       (U_SUF_R|U_SUF_SCND|U_SUF_D|U_SUF_64b)    

// 128-bits variants
#define U_R16B       (U_SUF_R|U_SUF_ALL|U_SUF_B|U_SUF_128b)
#define U_R8H        (U_SUF_R|U_SUF_ALL|U_SUF_H|U_SUF_128b)
#define U_R4S        (U_SUF_R|U_SUF_ALL|U_SUF_S|U_SUF_128b)
#define U_R2D        (U_SUF_R|U_SUF_ALL|U_SUF_D|U_SUF_128b)

#define U_1R16B      (U_SUF_R|U_SUF_FRST|U_SUF_B|U_SUF_128b)
#define U_1R8H       (U_SUF_R|U_SUF_FRST|U_SUF_H|U_SUF_128b)
#define U_1R4S       (U_SUF_R|U_SUF_FRST|U_SUF_S|U_SUF_128b)
#define U_1R2D       (U_SUF_R|U_SUF_FRST|U_SUF_D|U_SUF_128b)

#define U_2R16B      (U_SUF_R|U_SUF_SCND|U_SUF_B|U_SUF_128b)
#define U_2R8H       (U_SUF_R|U_SUF_SCND|U_SUF_H|U_SUF_128b)
#define U_2R4S       (U_SUF_R|U_SUF_SCND|U_SUF_S|U_SUF_128b)
#define U_2R2D       (U_SUF_R|U_SUF_SCND|U_SUF_D|U_SUF_128b)

#define U_3R4S       (U_SUF_R|U_SUF_THRD|U_SUF_S|U_SUF_128b)

// Write arrangements
#define U_WB         (U_SUF_W|U_SUF_ALL|U_SUF_B)
#define U_WH         (U_SUF_W|U_SUF_ALL|U_SUF_H)
#define U_WS         (U_SUF_W|U_SUF_ALL|U_SUF_S)
#define U_WD         (U_SUF_W|U_SUF_ALL|U_SUF_D)

// 64-bits variants
#define U_W8B        (U_SUF_W|U_SUF_ALL|U_SUF_B|U_SUF_64b)
#define U_W4H        (U_SUF_W|U_SUF_ALL|U_SUF_H|U_SUF_64b)
#define U_W2S        (U_SUF_W|U_SUF_ALL|U_SUF_S|U_SUF_64b)
#define U_W1D        (U_SUF_W|U_SUF_ALL|U_SUF_D|U_SUF_64b)

// 128-bits variants
#define U_W16B       (U_SUF_W|U_SUF_ALL|U_SUF_B|U_SUF_128b)
#define U_W8H        (U_SUF_W|U_SUF_ALL|U_SUF_H|U_SUF_128b)
#define U_W4S        (U_SUF_W|U_SUF_ALL|U_SUF_S|U_SUF_128b)
#define U_W2D        (U_SUF_W|U_SUF_ALL|U_SUF_D|U_SUF_128b)
#define U_W1Q        (U_SUF_W|U_SUF_ALL|U_SUF_Q|U_SUF_128b)

// Read&Write arrangements
#define U_RWB        (U_RB|U_WB)
#define U_RWH        (U_RH|U_WH)
#define U_RWS        (U_RS|U_WS)
#define U_RWD        (U_RD|U_WD)

// 128-bits variants
#define U_RW8B       (U_R8B|U_W8B)
#define U_RW16B      (U_R16B|U_W16B)
#define U_RW4S       (U_R4S|U_W4S)
#define U_RW2D       (U_R2D|U_W2D)

#define U_1RW2D      (U_1R2D|U_1W2D)

#define U_R4Sto2D             0
static size_t a_r4sto2d[]     = {U_R4S, U_R2D};
#define U_1R2Sto4S            1
static size_t a_1r2sto4s[]    = {U_1R2S, U_1R4S};
#define U_2R2Sto4S            2
static size_t a_2r2sto4s[]    = {U_2R2S, U_2R4S};
#define U_R8Hto4S             3
static size_t a_r8hto4s[]     = {U_R8H, U_R4S};
#define U_R4Hto2S             4
static size_t a_r4hto2s[]     = {U_R4H, U_R2S};
#define U_R4Hto8H             5
static size_t a_r4hto8h[]     = {U_R4H, U_R8H};
#define U_2R4Hto8H            6
static size_t a_2r4hto8h[]    = {U_2R4H, U_2R8H};
#define U_R8Bto16B            7
static size_t a_r8bto16b[]    = {U_R8B, U_R16B};
#define U_R8Hto2D             8
static size_t a_r8hto2d[]     = {U_R8H, U_R4S, U_R2D};
#define U_R8Bto4S             9
static size_t a_r8bto4s[]     = {U_R8B, U_R16B, U_R4H, U_R8H, U_R2S, U_R4S};
#define U_W1Dto2D             10
static size_t a_w1dto2d[]     = {U_W1D, U_W2D};
#define U_W4Sto2D             11
static size_t a_w4sto2d[]     = {U_W4S, U_W2D};
#define U_W2Sto4S             12
static size_t a_w2sto4s[]     = {U_W2S, U_W4S};
#define U_W8Hto4S             13
static size_t a_w8hto4s[]     = {U_W8H, U_W4S};
#define U_W4Hto2S             14
static size_t a_w4hto2s[]     = {U_W4H, U_W2S};
#define U_W4Hto8H             15
static size_t a_w4hto8h[]     = {U_W4H, U_W8H};
#define U_W8Bto16B            16
static size_t a_w8bto16b[]    = {U_W8B, U_W16B};
#define U_W16Bto4S            17
static size_t a_w16bto4s[]    = {U_W16B, U_W8H, U_W4S};
#define U_W8Bto2S             18
static size_t a_w8bto2s[]     = {U_W8B, U_W4H, U_W2S};
#define U_W4Hto2D             19
static size_t a_w4hto2d[]     = {U_W4H, U_W8H, U_W2S, U_W4S, U_W1D, U_W2D};
#define U_W8Bto2D             20
static size_t a_w8bto2d[]     = {U_W8B, U_W16B, U_W4H, U_W8H, U_W2S, U_W4S, U_W1D, U_W2D};
#define U_RW2Sto4S            21
static size_t a_rw2sto4s[]    = {U_R2S|U_W2S, U_R4S|U_W4S};
#define U_RW4Hto8H            22
static size_t a_rw4hto8h[]    = {U_R4H|U_W4H, U_R8H|U_W8H};
#define U_RW8Bto16B           23
static size_t a_rw8to16b[]    = {U_R8B|U_W8B, U_R16B|U_W16B};
#define U_RW8Bto4S            24
static size_t a_rw8bto4s[]    = {U_R8B|U_W8B, U_R16B|U_W16B, U_R4H|U_W4H, U_R8H|U_W8H, U_R2S|U_W2S, U_R4S|U_W4S};

static size_t* variable_suffixes[] = {a_r4sto2d, a_1r2sto4s, a_2r2sto4s, a_r8hto4s, a_r4hto2s, a_r4hto8h, a_2r4hto8h,
                                       a_r8bto16b, a_r8hto2d, a_r8bto4s, a_w1dto2d, a_w4sto2d, a_w2sto4s,  a_w8hto4s,
                                       a_w4hto2s, a_w4hto8h, a_w8bto16b, a_w16bto4s, a_w8bto2s, a_w4hto2d, a_w8bto2d,
                                       a_rw2sto4s, a_rw4hto8h, a_rw8to16b, a_rw8bto4s};

/* Macros used in the grammar defines (created to exclude some registers) */
#define BIN_VAL_0_0000(OUT)   {OUT=&arm_values[0];}
#define BIN_VAL_1_0000(OUT)   {OUT=&arm_values[1];}
#define BIN_VAL_2_0000(OUT)   {OUT=&arm_values[2];}
#define BIN_VAL_3_0000(OUT)   {OUT=&arm_values[3];}
#define BIN_VAL_4_0000(OUT)   {OUT=&arm_values[4];}
#define BIN_VAL_5_0000(OUT)   {OUT=&arm_values[5];}
#define BIN_VAL_6_0000(OUT)   {OUT=&arm_values[6];}
#define BIN_VAL_7_0000(OUT)   {OUT=&arm_values[7];}
#define BIN_VAL_8_0000(OUT)   {OUT=&arm_values[8];}
#define BIN_VAL_9_0000(OUT)   {OUT=&arm_values[9];}
#define BIN_VAL_10_0000(OUT)  {OUT=&arm_values[10];}
#define BIN_VAL_11_0000(OUT)  {OUT=&arm_values[11];}
#define BIN_VAL_12_0000(OUT)  {OUT=&arm_values[12];}
#define BIN_VAL_13_0000(OUT)  {OUT=&arm_values[13];}
#define BIN_VAL_14_0000(OUT)  {OUT=&arm_values[14];}
#define BIN_VAL_15_0000(OUT)  {OUT=&arm_values[15];}
#define BIN_VAL_16_0000(OUT)  {OUT=&arm_values[16];}
#define BIN_VAL_17_0000(OUT)  {OUT=&arm_values[17];}
#define BIN_VAL_18_0000(OUT)  {OUT=&arm_values[18];}
#define BIN_VAL_19_0000(OUT)  {OUT=&arm_values[19];}
#define BIN_VAL_20_0000(OUT)  {OUT=&arm_values[20];}
#define BIN_VAL_21_0000(OUT)  {OUT=&arm_values[21];}
#define BIN_VAL_22_0000(OUT)  {OUT=&arm_values[22];}
#define BIN_VAL_23_0000(OUT)  {OUT=&arm_values[23];}
#define BIN_VAL_24_0000(OUT)  {OUT=&arm_values[24];}
#define BIN_VAL_25_0000(OUT)  {OUT=&arm_values[25];}
#define BIN_VAL_26_0000(OUT)  {OUT=&arm_values[26];}
#define BIN_VAL_27_0000(OUT)  {OUT=&arm_values[27];}
#define BIN_VAL_28_0000(OUT)  {OUT=&arm_values[28];}
#define BIN_VAL_29_0000(OUT)  {OUT=&arm_values[29];}
#define BIN_VAL_30_0000(OUT)  {OUT=&arm_values[30];}
#define BIN_VAL_31_0000(OUT)  {OUT=&arm_values[31];}

/* --- USER FUNCTIONS --- */

static void insn_set_oprnds_arrangements(insn_t* insn, size_t insn_suffixes, data_size_t read_size){\
   if (insn == NULL)\
      return;\
   arrangement_t arrangement = NONE;\
   int i, read_index = 0, write_index = 0;\
   for (i = 0; i < insn->nb_oprnd; i++) {\
      oprnd_t* oprnd = insn_get_oprnd(insn, i);\
      if (oprnd_get_role(oprnd) == OP_ROLE_SRC)\
         read_index++;\
      else if (oprnd_get_role(oprnd) == OP_ROLE_SRC)\
         write_index++;\
      if ( ((oprnd_get_role(oprnd) == OP_ROLE_SRC && (insn_suffixes&U_SUF_R))\
              && (!(insn_suffixes&U_SUF_FRST) || (read_index == 1)) && (!(insn_suffixes&U_SUF_SCND) || (read_index == 2)))\
           || ((oprnd_get_role(oprnd) == OP_ROLE_DST && (insn_suffixes&U_SUF_W))\
              && (!(insn_suffixes&U_SUF_FRST) || (write_index == 1)) && (!(insn_suffixes&U_SUF_SCND) || (write_index == 2))) ) {\
         if (insn_suffixes&U_SUF_B) {\
            if (insn_suffixes&U_SUF_64b)\
               arrangement = B8;\
            else if (insn_suffixes&U_SUF_128b)\
               arrangement = B16;\
            else\
               arrangement = B;\
         } if (insn_suffixes&U_SUF_H) {\
            if (insn_suffixes&U_SUF_64b)\
               arrangement = H4;\
            else if (insn_suffixes&U_SUF_128b)\
               arrangement = H8;\
            else\
               arrangement = H;\
         } if (insn_suffixes&U_SUF_S) {\
            if (insn_suffixes&U_SUF_64b)\
               arrangement = S2;\
            else if (insn_suffixes&U_SUF_128b)\
               arrangement = S4;\
            else\
               arrangement = S;\
         } if (insn_suffixes&U_SUF_D) {\
            if (insn_suffixes&U_SUF_64b)\
               arrangement = D1;\
            else if (insn_suffixes&U_SUF_128b)\
               arrangement = D2;\
            else\
               arrangement = D;\
         }\
      }\
      if (oprnd_get_ext(oprnd) == NULL)\
         oprnd_set_ext(oprnd, arm64_oprnd_ext_new());\
      arm64_oprnd_ext_set_arrangement(oprnd_get_ext(oprnd), arrangement);\
   }\
   if (read_size == DATASZ_VAR) {\
      if ((insn_suffixes&(U_SUF_R|U_SUF_32b)) == (U_SUF_R|U_SUF_32b))\
         insn_set_read_size(insn, DATASZ_32b);\
      else if ((insn_suffixes&(U_SUF_R|U_SUF_64b)) == (U_SUF_R|U_SUF_64b))\
         insn_set_read_size(insn, DATASZ_64b);\
      else if ((insn_suffixes&(U_SUF_R|U_SUF_128b)) == (U_SUF_R|U_SUF_128b))\
         insn_set_read_size(insn, DATASZ_128b);\
   } else {\
      insn_set_read_size(insn, read_size);\
   }\
}

/* --- END OF USER FUNCTIONS --- */

/* --- USER MACROS --- */

/* Coding conventions :
 * - User macros ALWAYS start with 'U_'..
 * - Token or value/variable manipulations have more conventions :
 *    - followed by a word describing the operation.. (optional, getters does not need one)
 *    - followed by a word describing the inputs..    (mandatory)
 *    - followed by a word describing the output      (optional, the operation 'word' often make the output implicit)
 *
 * Input types :
 * - TOK
 * - VAR (a variable is an int64_t value)
 *
 * Examples :
 * - U_TOKS_SVAL:       Take multiple tokens and build a signed value. Considered as a getter.
 * - U_APPEND_VARTOK :  Take a variable and a token, append them. The output is implicitly an unsigned value.
 *                      There would be a "SVAL" suffix for a signed value return.
 */

/**
 * Returns the value contained in a token
 * \param T Pointer to the token
 * */
#define U_TOK_VAL(T) paramcoding_getvalue(T)

 /**
  * Returns the length of a token
  * \param T Pointer to the token
  * */
#define U_TOK_LEN(T) paramcoding_getlength(T)

/**
 * Returns the noped value contained in a token
 * \param T Pointer to the token
 * */
#define U_TOK_NVAL(T) (paramcoding_getvalue(T)^((1<<paramcoding_getlength(T))-1))

/**
 * Returns the signed value contained in a token
 * \param T pointer to the token
 * */
#define U_TOK_SVAL(T) paramcoding_getsignedvalue(T)

/**
 * Returns the value contained in a token signed with a second token
 * \param S Pointer to the token coding the sign
 * \param T Pointer to the token coding the value
 * It is NOT a sign extend ! The sign token specify if the value is negative or positive.
 */
#define U_TOKS_SVAL(S,T) (paramcoding_getvalue(S)?paramcoding_getvalue(T):(0 - paramcoding_getvalue(T)))

/**
 * Signs a unsigned value with a token
 * \param S Pointer to the token coding the sign
 * \param V Unsigned value
 * It is NOT a sign extend ! The sign token specify if the value is negative or positive.
 */
#define U_TOKVAR_SVAL(S,V) (paramcoding_getvalue(S)?V:(-V))

/**
 * Signs extend a unsigned value
 * \param V The unsigned value
 * \param S Bitsize of the value
 * It IS a sign extend !
 * (-2^63 XOR 2^(S-1)) XOR V
 */
#define U_SIGN_VAR(V,S) ( ((V>>(S-1))&0x1)?((((int64_t)0xFFFFFFFFFFFFFFFF) ^ (((0x1) << S) - 1)) ^ (V)):V )

/**
 * Appends two tokens and returns the built value
 * \param T1 Pointer to the first token
 * \param T2 Pointer to the second token
 * */
#define U_APPEND_TOKS(T1,T2) ((paramcoding_getvalue(T1)<<paramcoding_getlength(T2))|paramcoding_getvalue(T2))

/**
 * Appends a variable and a token and returns the built value
 * \param V Variable's value
 * \param T Pointer to the token
 * We need the size of the low part to append the two values.
 * */
#define U_APPEND_VARTOK(V,T) ((V<<paramcoding_getlength(T))|paramcoding_getvalue(T))

/**
 * Appends a token and a token and returns the built value
 * \param T Pointer to the token
 * \param V Variable's value
 * \param S Bitsize of the variable
 * We need the size of the low part to append the two values.
 * */
#define U_APPEND_TOKVAR(T,V,S) ((paramcoding_getvalue(T)<<S)|V)

/**
 * Appends two variables and returns the built value
 * \param V1 First variable's value
 * \param V2 Second variable's value
 * \param S Bitsize of the second variable
 * We need the size of the low part to append the two values.
 * */
#define U_APPEND_VARS(V1,V2,S) ((V1<<S)|V2)

/**
 * Gets the inverted token value
 * (Inverted value : (maximum the bitfield may encode + 1) - token value)
 * \param T The token
 */
#define U_INVERT_TOK(T) ((1<<paramcoding_getlength(T))-paramcoding_getvalue(T))

/**
 * Gets the inverted value
 * (Inverted value : (maximum the bitfield may encode + 1) - value)
 * \param V The value
 * \param S The value bitsize
 */
#define U_INVERT_VAL(V,S) ((1<<S)-V)

/**
 * Gets the inverted value of a split token
 * (Inverted value : (maximum the bitfield may encode + 1) - token value)
 * \param T1 The first token
 * \param T2 The second token
 */
#define U_INVERT_APPEND_TOKVAL(T1,T2) ( (1<<(paramcoding_getlength(T1) + paramcoding_getlength(T2))) - \
      ((paramcoding_getvalue(T1) << paramcoding_getlength(T2)) | paramcoding_getvalue(T2)) )

/*
 * Add the operands returned by a macro creating multiple ones to an instruction.
 */
#define U_INSN_ADD_MULTIPLE_OPRND(INSN,OPRN_LIST){\
   oprnd_t** oprn_list = (oprnd_t**)OPRN_LIST;\
   int i = 0;\
   for (i=0; i<U_MAX_LIST_OPRND; i++){\
      if (oprn_list[i] != NULL){\
         insn_add_oprnd(INSN, oprn_list[i]);\
         DBGMSG("OPRND ADDED: R%d.\n",i);\
      }\
   }\
   lc_free(oprn_list);\
}

#define U_SET_ELEMENT_INFO(INSN,ARRANGEMENT,OUTPUT_TYPE,INPUT_TYPE,OUTPUT_SIZE,INPUT_SIZE){\
   insn_set_output_element_type(INSN,OUTPUT_TYPE);\
   insn_set_input_element_type(INSN,INPUT_TYPE);\
   if (OUTPUT_SIZE == DATASZ_VAR){\
      if (ARRANGEMENT&U_SUF_B&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_8b);\
      else if (ARRANGEMENT&U_SUF_H&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_16b);\
      else if (ARRANGEMENT&U_SUF_S&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_32b);\
      else if (ARRANGEMENT&U_SUF_D&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_64b);\
      else if (ARRANGEMENT&U_SUF_Q&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_128b);\
   } else \
      insn_set_output_element_size(INSN,OUTPUT_SIZE);\
   if (INPUT_SIZE == DATASZ_VAR){\
      if (ARRANGEMENT&U_SUF_B&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_8b);\
      else if (ARRANGEMENT&U_SUF_H&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_16b);\
      else if (ARRANGEMENT&U_SUF_S&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_32b);\
      else if (ARRANGEMENT&U_SUF_D&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_64b);\
      else if (ARRANGEMENT&U_SUF_Q&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_128b);\
   } else \
      insn_set_input_element_size(INSN,INPUT_SIZE);\
}

#define U_SET_OUTPUT_ELEMENT_INFO(INSN,ARRANGEMENT,OUTPUT_TYPE,OUTPUT_SIZE){\
   insn_set_output_element_type(INSN,OUTPUT_TYPE);\
   if (OUTPUT_SIZE == DATASZ_VAR){\
      if (ARRANGEMENT&U_SUF_B&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_8b);\
      else if (ARRANGEMENT&U_SUF_H&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_16b);\
      else if (ARRANGEMENT&U_SUF_S&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_32b);\
      else if (ARRANGEMENT&U_SUF_D&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_64b);\
      else if (ARRANGEMENT&U_SUF_Q&U_SUF_W)\
         insn_set_output_element_size(INSN,DATASZ_128b);\
   } else \
      insn_set_output_element_size(INSN,OUTPUT_SIZE);\
}

#define U_SET_INPUT_ELEMENT_INFO(INSN,ARRANGEMENT,INPUT_TYPE,INPUT_SIZE){\
   insn_set_input_element_type(INSN,INPUT_TYPE);\
   if (INPUT_SIZE == DATASZ_VAR){\
      if (ARRANGEMENT&U_SUF_B&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_8b);\
      else if (ARRANGEMENT&U_SUF_H&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_16b);\
      else if (ARRANGEMENT&U_SUF_S&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_32b);\
      else if (ARRANGEMENT&U_SUF_D&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_64b);\
      else if (ARRANGEMENT&U_SUF_Q&U_SUF_R)\
         insn_set_input_element_size(INSN,DATASZ_128b);\
   } else \
      insn_set_input_element_size(INSN,INPUT_SIZE);\
}

/* --- END OF USER MACROS --- */

/* --- DISASSEMBLING MACROS --- */

/*  -  UTILITY MACROS  -  */

#define ADDITION_1200(MCR0,CST0,CST1) ((int64_t)MCR0 + U_##CST1)
/* 
* Possible arguments:
*  MCR0: LEFT_SHIFT 
*  CST0: DATASZ_UNDEF 
*  CST1: CI16 CI24 CI32 CI8 
*/

#define CONCATENATE_0102(CST0,TOK0,TOK1) (U_APPEND_TOKS(TOK0, TOK1))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  TOK0: IMM19 IMM6 
*  TOK1: IMM2 IMM6_2 
*/

#define CONCATENATE_0103(CST0,TOK0,TOK1,TOK2) (U_APPEND_VARTOK(U_APPEND_TOKS(TOK0, TOK1), TOK2))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  TOK0: IMM1 
*  TOK1: IMM6 
*  TOK2: IMM6_2 
*/

#define CONCATENATE_0105(CST0,TOK0,TOK1,TOK2,TOK3,TOK4) (U_APPEND_VARTOK(U_APPEND_VARTOK(U_APPEND_VARTOK(U_APPEND_TOKS(TOK0, TOK1), TOK2), TOK3), TOK4))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  TOK0: O0 
*  TOK1: OPC1 
*  TOK2: CRN 
*  TOK3: CRM 
*  TOK4: OPC2 
*/

#define CONCATENATE_0201(CST0,CST1,TOK0) (U_APPEND_VARTOK(U_##CST1,TOK0))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: CI1 
*  TOK0: IMM5 
*/

// Special case
#define CONCATENATE_7101(MCR0,MCR1,MCR2,MCR3,MCR4,MCR5,MCR6,CST0,TOK0) (((uint64_t)MCR0 << 56) | ((uint64_t)MCR1 << 48) | ((uint64_t)MCR2 << 40)| ((uint64_t)MCR3 << 32) | ((uint64_t)MCR4 << 24) | ((uint64_t)MCR5 << 16) | ((uint64_t)MCR6 << 8) | U_TOK_VAL(TOK0))
/* 
* Possible arguments:
*  MCR0: LEFT_FILL 
*  MCR1: LEFT_FILL 
*  MCR2: LEFT_FILL 
*  MCR3: LEFT_FILL 
*  MCR4: LEFT_FILL 
*  MCR5: LEFT_FILL 
*  MCR6: LEFT_FILL 
*  CST0: DATASZ_UNDEF 
*  TOK0: H 
*/

/* 
* Building of a 64 bit floating value
* X NOT(Y) ZZZZ-ZZZZ ABCD-EF 0000....0 
*/
#define CONCATENATE_DWORD_FLOAT_2102(MCR0,MCR1,CST0,TOK0,TOK1) ((U_TOK_VAL(TOK0) << 63) | ((uint64_t)MCR0 << 62) | ((uint64_t)MCR1 << 54) | (U_TOK_VAL(TOK1) << 48))
/* 
* Possible arguments:
*  MCR0: NOT 
*  MCR1: LEFT_FILL 
*  CST0: DATASZ_UNDEF 
*  TOK0: A 
*  TOK1: IMM6 
*/

/* 
* Building of a 64 bit floating value
* X NOT(Y) ZZZZ-ZZZZ A BCDE-F 0000....0 
*/
#define CONCATENATE_DWORD_FLOAT_2103(MCR0,MCR1,CST0,TOK0,TOK1,TOK2) ((U_TOK_VAL(TOK0) << 63) | ((uint64_t)MCR0 << 62) | ((uint64_t)MCR1 << 54) | (U_TOK_VAL(TOK1) << 53) | (U_TOK_VAL(TOK1) << 48))
/* 
* Possible arguments:
*  MCR0: NOT 
*  MCR1: LEFT_FILL 
*  CST0: DATASZ_UNDEF 
*  TOK0: A 
*  TOK1: IMM1 
*  TOK2: IMM5 
*/

/* 
* Building of a 32 bit floating value
* X NOT(Y) ZZZZ-Z ABCD-EF 0000....0 
*/
#define CONCATENATE_SWORD_FLOAT_2102(MCR0,MCR1,CST0,TOK0,TOK1) ((U_TOK_VAL(TOK0) << 31) | ((uint64_t)MCR0 << 30) | ((uint64_t)MCR1 << 25) | (U_TOK_VAL(TOK1) << 19))
/* 
* Possible arguments:
*  MCR0: NOT 
*  MCR1: LEFT_FILL 
*  CST0: DATASZ_UNDEF 
*  TOK0: A 
*  TOK1: IMM6 
*/

/* 
* Building of a 32 bit floating value
* X NOT(Y) ZZZZ-Z A BCD-EF 0000....0 
*/
#define CONCATENATE_SWORD_FLOAT_2103(MCR0,MCR1,CST0,TOK0,TOK1,TOK2) ((U_TOK_VAL(TOK0) << 31) | ((uint64_t)MCR0 << 30) | ((uint64_t)MCR1 << 25) | (U_TOK_VAL(TOK1) << 24) | (U_TOK_VAL(TOK1) << 19))
/* 
* Possible arguments:
*  MCR0: NOT 
*  MCR1: LEFT_FILL 
*  CST0: DATASZ_UNDEF 
*  TOK0: A 
*  TOK1: IMM1 
*  TOK2: IMM5 
*/

#define FLOAT_CAST_DWORD_1100(MCR0,CST0) ((double)MCR0)
/* 
* Possible arguments:
*  MCR0: LEFT_SHIFT 
*  CST0: DATASZ_UNDEF 
*/

#define FLOAT_CAST_SWORD_1100(MCR0,CST0) ((float)MCR0)
/* 
* Possible arguments:
*  MCR0: LEFT_SHIFT 
*  CST0: DATASZ_UNDEF 
*/

#define INCREMENT_1100(MCR0,CST0) ((int64_t)MCR0 + 1)
/* 
* Possible arguments:
*  MCR0: ONE_COMPLEMENT 
*  CST0: DATASZ_UNDEF 
*/

#define LEFT_FILL_0201(CST0,CST1,TOK0) ((U_TOK_VAL(TOK0) << (U_##CST1 + 1)) - 1)
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: ONE 
*  TOK0: S 
*/

#define LEFT_SHIFT_0201(CST0,CST1,TOK0) (U_TOK_VAL(TOK0) << U_##CST1)
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: FOUR ONE THREE TWO 
*  TOK0: IMM1 IMM12 IMM14 IMM19 IMM2 IMM26 IMM7 S 
*/

#define LEFT_SHIFT_1200(MCR0,CST0,CST1) ((int64_t)MCR0 << U_##CST1)
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  CST0: DATASZ_UNDEF 
*  CST1: TWELVE 
*/

#define NOT_0101(CST0,TOK0) (!U_TOK_VAL(TOK0))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  TOK0: B 
*/

#define ONE_COMPLEMENT_0101(CST0,TOK0) (U_INVERT_TOK(TOK0)-1)
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  TOK0: IMM3 IMM4 IMM5 IMM6 
*/

#define SIGNED_LEFT_SHIFT_0201(CST0,CST1,TOK0) (U_TOK_SVAL(TOK0) * (1 << U_##CST1))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: TWO 
*  TOK0: IMM19 
*/

/*  -  END OF UTILITY MACROS  -  */

/*  -  INSTRUCTIONS AND OPERANDS MACROS  -  */
//TODO HANDLE CONDITIONS
#define BIN_CONDITION_0101(OUT,CST0,TOK0){\
   OUT = oprnd_new_imm(U_TOK_VAL(TOK0));\
   oprnd_set_bitsize(OUT, CST0);\
   DBGMSG("BIN_CONDITION_0101: %ld\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_UNDEF 
*	TOK0: CND 
*/

#define INSN_OPCODE_0a00(OUT,VARIANT_ID,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT,CST0);\
   insn_set_variant_id(OUT,VARIANT_ID);\
   insn_set_annotate(OUT,CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   DBGMSG("INSN_OPCODE_0a00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  CST0: I_DRPS I_ERET I_ISB I_RET 
*  CST1: ISET_ARM64 
*  CST2: FM_HW FM_RET FM_SYNC 
*  CST3: A_NA 
*  CST4: S_SCALAR 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_UNDEF 
*  CST8: DATASZ_UNDEF 
*  CST9: DATASZ_UNDEF 
* Used in: template 
*/

#define INSN_OPCODE_1a00(OUT,VARIANT_ID,MCR0,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   DBGMSG("INSN_OPCODE_1a00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_IMMEDIATE OPRN_POINTER OPRN_REGISTER_DWORD_OR_ZERO 
*  CST0: I_B I_BL I_BLR I_BR I_BRK I_CLREX I_DCPS1 I_DCPS2 I_DCPS3 I_DMB 
*     I_DSB I_HINT I_HLT I_HVC I_ISB I_RET I_SMC I_SVC 
*  CST1: ISET_ARM64 
*  CST2: FM_CALL FM_HW FM_JUMP FM_OS FM_RET FM_SYNC 
*  CST3: A_CALL A_JUMP A_NA 
*  CST4: S_SCALAR 
*  CST5: T_UNDEF 
*  CST6: T_INT T_SINT T_UNDEF 
*  CST7: DATASZ_UNDEF 
*  CST8: DATASZ_64b DATASZ_UNDEF 
*  CST9: DATASZ_64b DATASZ_UNDEF 
* Used in: template 
*/

//TODO handle CONDITIONS
#define INSN_OPCODE_1a01(OUT,VARIANT_ID,MCR0,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3|A_CONDITIONAL);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   DBGMSG("INSN_OPCODE_1a01: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_POINTER 
*  CST0: I_B 
*  CST1: ISET_ARM64 
*  CST2: FM_JUMP 
*  CST3: A_JUMP 
*  CST4: S_SCALAR 
*  CST5: T_UNDEF 
*  CST6: T_SINT 
*  CST7: DATASZ_UNDEF 
*  CST8: DATASZ_UNDEF 
*  CST9: DATASZ_UNDEF 
*  TOK0: CND 
* Used in: template 
*/

#define INSN_OPCODE_2a00(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   DBGMSG("INSN_OPCODE_2a00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_IMMEDIATE OPRN_REGISTER_DWORD_OR_STACK OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_QWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_STACK OPRN_REGISTER_SWORD_OR_ZERO 
*     OPRN_REGISTER_SYSTEM 
*  MCR1: OPRN_IMMEDIATE OPRN_MEMORY OPRN_MEMORY_DWORD_REGISTER_INDEX OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_WRITEBACK OPRN_MEMORY_SIGNED_IMMEDIATE_POST_INDEX OPRN_MEMORY_SWORD_REGISTER_INDEX OPRN_MEMORY_UNSIGNED_IMMEDIATE_INDEX OPRN_POINTER OPRN_REGISTER_DWORD_OR_STACK 
*     OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_STACK OPRN_REGISTER_SWORD_OR_ZERO OPRN_REGISTER_SYSTEM 
*  CST0: I_ABS I_ADR I_ADRP I_CBNZ I_CBZ I_CLS I_CLZ I_CMN I_CMP I_FABS 
*     I_FCMP I_FCMPE I_FCVT I_FCVTAS I_FCVTAU I_FCVTMS I_FCVTMU I_FCVTNS I_FCVTNU I_FCVTPS 
*     I_FCVTPU I_FCVTXN I_FCVTZS I_FCVTZU I_FMOV I_FNEG I_FRECPE I_FRECPX I_FRINTA I_FRINTI 
*     I_FRINTM I_FRINTN I_FRINTP I_FRINTX I_FRINTZ I_FRSQRTE I_FSQRT I_LDAR I_LDARB I_LDARH 
*     I_LDAXR I_LDAXRB I_LDAXRH I_LDR I_LDRB I_LDRH I_LDRSB I_LDRSH I_LDRSW I_LDTR 
*     I_LDTRB I_LDTRH I_LDTRSB I_LDTRSH I_LDTRSW I_LDUR I_LDURB I_LDURH I_LDURSB I_LDURSH 
*     I_LDURSW I_LDXR I_LDXRB I_LDXRH I_MOVI I_MOVK I_MOVN I_MOVZ I_MRS I_MSR 
*     I_NEG I_PRFM I_PRFUM I_RBIT I_REV I_REV16 I_REV32 I_SCVTF I_SHA1H I_SQABS 
*     I_SQNEG I_SQXTN I_SQXTUN I_STLR I_STLRB I_STLRH I_STR I_STRB I_STRH I_STTR 
*     I_STTRB I_STTRH I_STUR I_STURB I_STURH I_SUQADD I_UCVTF I_UQXTN I_USQADD 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_BSWAP FM_CJUMP FM_CMP FM_CNT FM_CRYPTO FM_CVT FM_LOAD FM_MOV 
*     FM_NEG FM_PREFETCH FM_RCP FM_RND FM_SQRT FM_STORE FM_UNDEF 
*  CST3: A_NA A_SETFLAGS 
*  CST4: S_SCALAR S_SIMD 
*  CST5: T_BIT T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST6: T_BIT T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b DATASZ_UNDEF 
*  CST8: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b DATASZ_UNDEF 
*  CST9: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b DATASZ_UNDEF 
* Used in: template 
*/

#define INSN_OPCODE_2b00(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   DBGMSG("INSN_OPCODE_2b00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_DWORD_OR_STACK OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SIMD_VECTOR OPRN_REGISTER_SWORD_OR_STACK 
*  MCR1: OPRN_IMMEDIATE OPRN_REGISTER_DWORD_OR_STACK OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_VECTOR OPRN_REGISTER_SWORD_OR_STACK 
*  CST0: I_ABS I_ADDP I_ADDV I_DUP I_FABS I_FADDP I_FCVTAS I_FCVTAU I_FCVTMS I_FCVTMU 
*     I_FCVTNS I_FCVTNU I_FCVTPS I_FCVTPU I_FCVTZS I_FCVTZU I_FMAXNMP I_FMAXNMV I_FMAXP I_FMAXV 
*     I_FMINNMP I_FMINNMV I_FMINP I_FMINV I_FMOV I_FNEG I_FRECPE I_FRINTA I_FRINTI I_FRINTM 
*     I_FRINTN I_FRINTP I_FRINTX I_FRINTZ I_FRSQRTE I_FSQRT I_MOV I_MOVI I_NEG I_SADDLV 
*     I_SCVTF I_SHA1SU1 I_SHA256SU0 I_SMAXV I_SMINV I_SMOV I_SQABS I_SQNEG I_SUQADD I_UADDLV 
*     I_UCVTF I_UMAXV I_UMINV I_UMOV I_USQADD 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_CRYPTO FM_CVT FM_MAX FM_MIN FM_MOV FM_NEG FM_RCP FM_RND 
*     FM_SQRT 
*  CST3: A_NA 
*  CST4: S_SCALAR S_SIMD 
*  CST5: T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST6: T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST10: R2D R2S R4S RB RD RH RS RW2D RW4S RWB 
*     RWD RWH RWS W2D WD 
* Used in: template 
*/

#define INSN_OPCODE_2b01(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_2b01: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_IMMEDIATE OPRN_REGISTER_SIMD_VECTOR OPRN_REGISTER_SWORD_OR_ZERO 
*  CST0: I_ADDV I_BIC I_CNT I_DUP I_FABS I_FCVTAS I_FCVTAU I_FCVTMS I_FCVTMU I_FCVTNS 
*     I_FCVTNU I_FCVTPS I_FCVTPU I_FCVTZS I_FCVTZU I_FMOV I_FNEG I_FRECPE I_FRINTA I_FRINTI 
*     I_FRINTM I_FRINTN I_FRINTP I_FRINTX I_FRINTZ I_FRSQRTE I_FSQRT I_MOVI I_MVN I_MVNI 
*     I_ORR I_RBIT I_REV16 I_REV32 I_SADDLV I_SCVTF I_SMAXV I_SMINV I_UADDLV I_UCVTF 
*     I_UMAXV I_UMINV I_URECPE I_URSQRTE 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_BSWAP FM_CLR FM_CNT FM_CVT FM_MAX FM_MIN FM_MOV FM_NEG 
*     FM_NOT FM_OR FM_RCP FM_RND FM_SQRT FM_UNDEF 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_BIT T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST6: T_BIT T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_16b DATASZ_32b DATASZ_8b DATASZ_VAR 
*  CST10: R4Hto8H R8Bto16B RW2Sto4S RW4Hto8H RW8Bto16B W2Sto4S W4Hto8H W8Bto16B 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_2b11(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,VAR0,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)],CST5,CST6,CST7,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_2b11: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_ABS I_CLS I_CLZ I_NEG I_REV64 I_SQABS I_SQNEG I_SUQADD I_USQADD 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_BSWAP FM_CNT FM_NEG 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_BIT T_INT T_SINT T_UINT T_UNDEF 
*  CST6: T_BIT T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_VAR 
*  CST8: DATASZ_VAR 
*  CST9: DATASZ_VAR 
*  CST10: RW8Bto4S 
*  VAR0: AS 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_2c00(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST11, CST9);\
   DBGMSG("INSN_OPCODE_2c00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_AESD I_AESE I_AESIMC I_AESMC I_DUP I_FCVTXN I_FCVTXN2 I_SQXTN I_SQXTN2 I_SQXTUN 
*     I_SQXTUN2 I_UQXTN I_UQXTN2 I_XTN I_XTN2 
*  CST1: ISET_ARM64 
*  CST2: FM_CRYPTO FM_CVT FM_MOV 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_FP T_SINT T_UINT T_UNDEF 
*  CST6: T_FP T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_64b 
*  CST10: W16B W2D W2S W4H W4S W8B W8H 
*  CST11: R16B R2D R4S R8H RD 
* Used in: template 
*/

#define INSN_OPCODE_2c01(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_OUTPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)],CST5,CST7);\
   if (U_##CST11 != U_RB && U_##CST11 != U_RH && U_##CST11 != U_RS) {\
      U_SET_INPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST11][U_TOK_VAL(TOK0)],CST6,CST8);\
   } else {\
      insn_set_input_element_type(OUT,CST6);\
      insn_set_input_element_size(OUT,CST8);\
   }\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)], CST9);\
   if (U_##CST11 != U_RB && U_##CST11 != U_RH && U_##CST11 != U_RS)\
      insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST11][U_TOK_VAL(TOK0)], CST9);\
   else\
      insn_set_oprnds_arrangements(OUT, (size_t)U_##CST11, CST9);\
   DBGMSG("INSN_OPCODE_2c01: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_DUP I_FCVTL I_FCVTL2 I_FCVTN I_FCVTN2 
*  CST1: ISET_ARM64 
*  CST2: FM_CVT FM_MOV 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_FP T_UNDEF 
*  CST6: T_FP T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_8b DATASZ_VAR 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_8b DATASZ_VAR 
*  CST9: DATASZ_16b DATASZ_32b DATASZ_8b DATASZ_VAR 
*  CST10: W2Sto4S W4Hto2S W4Hto8H W4Sto2D W8Bto16B W8Hto4S 
*  CST11: R4Hto2S R4Sto2D R8Hto4S RB RH RS 
*  TOK0: Q S 
* Used in: template 
*/

#define INSN_OPCODE_2c11(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11,VAR0,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_OUTPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)],CST5,CST7);\
   U_SET_INPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST11][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)],CST6,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)], CST9);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST11][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_2c11: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_SADALP I_SADDLP I_UADALP I_UADDLP 
*  CST1: ISET_ARM64 
*  CST2: FM_ADD 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_SINT T_UINT 
*  CST6: T_SINT T_UINT 
*  CST7: DATASZ_VAR 
*  CST8: DATASZ_VAR 
*  CST9: DATASZ_VAR 
*  CST10: W4Hto2D 
*  CST11: R8Bto4S 
*  VAR0: AS 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_3a00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   DBGMSG("INSN_OPCODE_3a00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_DWORD_OR_STACK OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_QWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_STACK OPRN_REGISTER_SWORD_OR_ZERO 
*  MCR1: OPRN_IMMEDIATE OPRN_REGISTER_DWORD_OR_STACK OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_QWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_STACK OPRN_REGISTER_SWORD_OR_ZERO 
*     
*  MCR2: OPRN_IMMEDIATE OPRN_MEMORY OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_WRITEBACK OPRN_MEMORY_SIGNED_IMMEDIATE_POST_INDEX OPRN_POINTER OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_BYTE OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD 
*     OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_ZERO 
*  CST0: I_ADC I_ADCS I_ADD I_ADDS I_AND I_ANDS I_ASR I_BIC I_BICS I_CMEQ 
*     I_CMGE I_CMGT I_CMHI I_CMHS I_CMLE I_CMLT I_CMTST I_CRC32B I_CRC32CB I_CRC32CH 
*     I_CRC32CW I_CRC32CX I_CRC32H I_CRC32W I_CRC32X I_EON I_EOR I_FABD I_FACGE I_FACGT 
*     I_FADD I_FCMEQ I_FCMGE I_FCMGT I_FCMLE I_FCMLT I_FCVTZS I_FCVTZU I_FDIV I_FMAX 
*     I_FMAXNM I_FMIN I_FMINNM I_FMUL I_FMULX I_FNMUL I_FRECPS I_FRSQRTS I_FSUB I_LDAXP 
*     I_LDNP I_LDP I_LDPSW I_LDXP I_LSL I_LSR I_ORN I_ORR I_ROR I_SBC 
*     I_SBCS I_SCVTF I_SDIV I_SHL I_SLI I_SMULH I_SQADD I_SQDMLAL I_SQDMLSL I_SQDMULH 
*     I_SQDMULL I_SQRDMULH I_SQRSHL I_SQRSHRN I_SQRSHRUN I_SQSHL I_SQSHLU I_SQSHRN I_SQSHRUN I_SQSUB 
*     I_SRI I_SRSHL I_SRSHR I_SRSRA I_SSHL I_SSHR I_SSRA I_STLXR I_STLXRB I_STLXRH 
*     I_STNP I_STP I_STXR I_STXRB I_STXRH I_SUB I_SUBS I_TBNZ I_TBZ I_UCVTF 
*     I_UDIV I_UMULH I_UQADD I_UQRSHL I_UQRSHRN I_UQSHL I_UQSHRN I_UQSUB I_URSHL I_URSHR 
*     I_URSRA I_USHL I_USHR I_USRA 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_AND FM_CJUMP FM_CLR FM_CMP FM_CVT FM_DIV FM_HASH FM_LOAD 
*     FM_MAX FM_MIN FM_MUL FM_NEG FM_OR FM_RCP FM_ROT FM_SHIFT FM_SQRT FM_STORE 
*     FM_SUB FM_XOR 
*  CST3: A_NA A_SETFLAGS 
*  CST4: S_SCALAR S_SIMD 
*  CST5: T_BIT T_FP T_INT T_SFXP T_SINT T_UFXP T_UINT T_UNDEF 
*  CST6: T_BIT T_FP T_INT T_SFXP T_SINT T_UFXP T_UINT T_UNDEF 
*  CST7: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b DATASZ_UNDEF 
*  CST8: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_16b DATASZ_256b DATASZ_32b DATASZ_64b DATASZ_8b 
* Used in: template 
*/

#define INSN_OPCODE_3b00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   DBGMSG("INSN_OPCODE_3b00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_QWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_LIST_FOUR_VECTOR OPRN_REGISTER_LIST_ONE_VECTOR OPRN_REGISTER_LIST_THREE_VECTOR OPRN_REGISTER_LIST_TWO_VECTOR OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_HWORD OPRN_REGISTER_SIMD_SCALAR_QWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_IMMEDIATE OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_ADD I_ADDP I_CMEQ I_CMGE I_CMGT I_CMHI I_CMHS I_CMLE I_CMLT I_CMTST 
*     I_FABD I_FACGE I_FACGT I_FADD I_FADDP I_FCMEQ I_FCMGE I_FCMGT I_FCMLE I_FCMLT 
*     I_FCVTZS I_FCVTZU I_FDIV I_FMAX I_FMAXNM I_FMAXNMP I_FMAXP I_FMIN I_FMINNM I_FMINNMP 
*     I_FMINP I_FMLA I_FMLS I_FMUL I_FMULX I_FRECPS I_FRSQRTS I_FSUB I_SCVTF I_SHA1C 
*     I_SHA1M I_SHA1P I_SHA1SU0 I_SHA256H I_SHA256H2 I_SHA256SU1 I_SHL I_SLI I_SQADD I_SQDMLAL 
*     I_SQDMLSL I_SQDMULH I_SQDMULL I_SQRDMULH I_SQRSHL I_SQSHL I_SQSHLU I_SQSUB I_SRI I_SRSHL 
*     I_SRSHR I_SRSRA I_SSHL I_SSHR I_SSRA I_SUB I_TBL I_TBLX I_TRN1 I_TRN2 
*     I_UCVTF I_UQADD I_UQRSHL I_UQSHL I_UQSUB I_URSHL I_URSHR I_URSRA I_USHL I_USHR 
*     I_USRA I_UZP1 I_UZP2 I_ZIP1 I_ZIP2 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_CMP FM_CRYPTO FM_CVT FM_DIV FM_FMA FM_FMS FM_MAX FM_MIN 
*     FM_MOV FM_MUL FM_RCP FM_SHIFT FM_SQRT FM_SUB 
*  CST3: A_NA 
*  CST4: S_SCALAR S_SIMD 
*  CST5: T_BIT T_FP T_INT T_SFXP T_SINT T_UFXP T_UINT T_UNDEF 
*  CST6: T_BIT T_FP T_INT T_SFXP T_SINT T_UFXP T_UINT T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b DATASZ_UNDEF 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b DATASZ_UNDEF 
*  CST9: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b 
*  CST10: 2RD 2RH 2RS 3R4S RW16B RW2D RW4S 
* Used in: template 
*/

#define INSN_OPCODE_3b01(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)],CST5,CST6,CST7,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_3b01: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_IMMEDIATE OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_AND I_BIC I_BIF I_BIT I_BSL I_EOR I_FABD I_FACGE I_FACGT I_FADD 
*     I_FADDP I_FCMEQ I_FCMGE I_FCMGT I_FCMLE I_FCMLT I_FCVTZS I_FCVTZU I_FDIV I_FMAX 
*     I_FMAXNM I_FMAXNMP I_FMAXP I_FMIN I_FMINNM I_FMINNMP I_FMINP I_FMLA I_FMLS I_FMUL 
*     I_FMULX I_FRECPS I_FRSQRTS I_FSUB I_MUL I_ORN I_ORR I_PMUL I_SCVTF I_SHL 
*     I_SLI I_SQDMULH I_SQRDMULH I_SQSHL I_SQSHLU I_SRI I_SRSHR I_SRSRA I_SSHR I_SSRA 
*     I_UCVTF I_UQSHL I_URSHR I_URSRA I_USHR I_USRA 
*  CST1: ISET_ARM64 
*  CST2: FM_ABS FM_ADD FM_AND FM_CLR FM_CMP FM_CVT FM_DIV FM_FMA FM_FMS FM_MAX 
*     FM_MIN FM_MOV FM_MUL FM_OR FM_RCP FM_SHIFT FM_SQRT FM_SUB FM_XOR 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_BIT T_FP T_INT T_SFXP T_SINT T_UFXP T_UINT 
*  CST6: T_BIT T_FP T_INT T_SFXP T_SINT T_UFXP T_UINT 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_16b DATASZ_32b DATASZ_8b DATASZ_VAR 
*  CST10: RW2Sto4S RW4Hto8H RW8Bto16B 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_3b11(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,VAR0,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)],CST5,CST6,CST7,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_3b11: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_IMMEDIATE OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_ADD I_ADDP I_CMEQ I_CMGE I_CMGT I_CMHI I_CMHS I_CMLE I_CMLT I_CMTST 
*     I_MLA I_MLS I_SABA I_SABD I_SHADD I_SHSUB I_SMAX I_SMAXP I_SMIN I_SMINP 
*     I_SQADD I_SQRSHL I_SQSHL I_SQSUB I_SRHADD I_SRSHL I_SSHL I_SUB I_TRN1 I_TRN2 
*     I_UABA I_UABD I_UHADD I_UHSUB I_UMAX I_UMAXP I_UMIN I_UMINP I_UQADD I_UQRSHL 
*     I_UQSHL I_UQSUB I_URHADD I_URSHL I_USHL I_UZP1 I_UZP2 I_ZIP1 I_ZIP2 
*  CST1: ISET_ARM64 
*  CST2: FM_ADD FM_CMP FM_CRYPTO FM_MAX FM_MIN FM_MOV FM_SHIFT FM_SUB 
*  CST3: A_NA 
*  CST4: S_SCALAR S_SIMD 
*  CST5: T_INT T_SINT T_UINT T_UNDEF 
*  CST6: T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_VAR 
*  CST8: DATASZ_VAR 
*  CST9: DATASZ_VAR 
*  CST10: RW8Bto4S 
*  VAR0: AS 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_3c00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST11, CST9);\
   DBGMSG("INSN_OPCODE_3c00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_IMMEDIATE OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_FMLA I_FMLS I_FMUL I_FMULX I_PMULL I_PMULL2 I_RADDHN I_RADDHN2 I_RSHRN I_RSHRN2 
*     I_RUSBHN I_RUSBHN2 I_SABAL I_SABAL2 I_SABDL I_SABDL2 I_SADDL I_SADDL2 I_SADDW I_SADDW2 
*     I_SHLL I_SHLL2 I_SHRN I_SHRN2 I_SMLAL I_SMLAL2 I_SMLSL I_SMLSL2 I_SMULL I_SMULL2 
*     I_SQDMLAL I_SQDMLAL2 I_SQDMLSL I_SQDMLSL2 I_SQDMULL I_SQDMULL2 I_SQRSHRN I_SQRSHRN2 I_SQRSHRUN I_SQRSHRUN2 
*     I_SQSHRN I_SQSHRN2 I_SQSHRUN I_SQSHRUN2 I_SSHLL I_SSHLL2 I_SSUBL I_SSUBL2 I_SUBHN I_SUBHN2 
*     I_UABAL I_UABAL2 I_UABDL I_UABDL2 I_UADDL I_UADDL2 I_UMLAL I_UMLAL2 I_UMLSL I_UMLSL2 
*     I_UMULL I_UMULL2 I_UQRSHRN I_UQRSHRN2 I_UQSHRN I_UQSHRN2 I_USHLL I_USHLL2 I_USUBL I_USUBL2 
*     
*  CST1: ISET_ARM64 
*  CST2: FM_ADD FM_FMA FM_FMS FM_MUL FM_RND FM_SHIFT FM_SUB 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST6: T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_64b 
*  CST10: 1R2D W16B W1Q W2D W2S W4H W4S W8B W8H 
*  CST11: 2RD R16B R1D R2D R2S R4H R4S R8B R8H 
* Used in: template 
*/

#define INSN_OPCODE_3c01(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_OUTPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)],CST5,CST7);\
   U_SET_INPUT_ELEMENT_INFO(OUT,(size_t)U_##CST11,CST6,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)], CST9);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST11, CST9);\
   DBGMSG("INSN_OPCODE_3c01: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_REGISTER_INDEXED_SIMD_VECTOR 
*  CST0: I_FMLA I_FMLS I_FMUL I_FMULX I_MLA I_MLS I_MUL 
*  CST1: ISET_ARM64 
*  CST2: FM_ADD FM_FMA FM_FMS FM_MUL FM_SUB 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_FP T_INT 
*  CST6: T_FP T_INT 
*  CST7: DATASZ_16b DATASZ_32b 
*  CST8: DATASZ_16b DATASZ_32b 
*  CST9: DATASZ_VAR 
*  CST10: 1R2Sto4S 2R2Sto4S 2R4Hto8H 
*  CST11: 2RS 3RH 3RS 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_3c10(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11,VAR0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_OUTPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][*(size_t*)VAR0],CST5,CST7);\
   U_SET_INPUT_ELEMENT_INFO(OUT,variable_suffixes[U_##CST11][*(size_t*)VAR0],CST6,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][*(size_t*)VAR0], CST9);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST11][*(size_t*)VAR0], CST9);\
   DBGMSG("INSN_OPCODE_3c10: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_ADDHN I_ADDHN2 
*  CST1: ISET_ARM64 
*  CST2: FM_ADD 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_SINT 
*  CST6: T_SINT 
*  CST7: DATASZ_VAR 
*  CST8: DATASZ_VAR 
*  CST9: DATASZ_VAR 
*  CST10: W16Bto4S W8Bto2S 
*  CST11: R8Hto2D 
*  VAR0: AS 
* Used in: template 
*/

#define INSN_OPCODE_3d00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,CST11,CST12){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST11, CST9);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST12, CST9);\
   DBGMSG("INSN_OPCODE_3d00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_LIST_FOUR_VECTOR OPRN_REGISTER_LIST_ONE_VECTOR OPRN_REGISTER_LIST_THREE_VECTOR OPRN_REGISTER_LIST_TWO_VECTOR OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_REGISTER_INDEXED_SIMD_VECTOR OPRN_REGISTER_SIMD_VECTOR 
*  CST0: I_SMLAL I_SMLAL2 I_SMLSL I_SMLSL2 I_SMULL I_SMULL2 I_SQDMLAL I_SQDMLAL2 I_SQDMLSL I_SQDMLSL2 
*     I_SQDMULH I_SQDMULL I_SQDMULL2 I_SQRDMULH I_SSUBW I_SSUBW2 I_TBL I_TBLX I_UADDW I_UADDW2 
*     I_UMLAL I_UMLAL2 I_UMLSL I_UMLSL2 I_UMULL I_UMULL2 I_USUBW I_USUBW2 
*  CST1: ISET_ARM64 
*  CST2: FM_ADD FM_MOV FM_MUL FM_SUB 
*  CST3: A_NA 
*  CST4: S_SCALAR S_SIMD 
*  CST5: T_SINT T_UINT T_UNDEF 
*  CST6: T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_64b 
*  CST10: W2D W2S W4H W4S W8B W8H 
*  CST11: 1R16B 1R2D 1R2S 1R4H 1R4S 1R8H 
*  CST12: 2R16B 2R2S 2R4H 2R4S 2R8B 2R8H 2RH 2RS 
* Used in: template 
*/

#define INSN_OPCODE_4a00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,MCR3,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   if (CST0 != I_CCMN && CST0 != I_CCMP && CST0 != I_CSEL && CST0 != I_CSINC && CST0 != I_CSINV\
      && CST0 != I_CSNEG)\
      insn_add_oprnd(OUT, MCR3);\
   DBGMSG("INSN_OPCODE_4a00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_IMMEDIATE OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_ZERO 
*  MCR1: OPRN_IMMEDIATE OPRN_IMMEDIATE_SYSTEM OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_ZERO 
*  MCR2: OPRN_IMMEDIATE OPRN_IMMEDIATE_SYSTEM OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_ZERO 
*  MCR3: BIN_CONDITION OPRN_IMMEDIATE OPRN_MEMORY OPRN_REGISTER_DWORD_OR_ZERO OPRN_REGISTER_SIMD_SCALAR_DWORD OPRN_REGISTER_SIMD_SCALAR_SWORD OPRN_REGISTER_SWORD_OR_ZERO 
*  CST0: I_BFM I_CCMN I_CCMP I_CSEL I_CSINC I_CSINV I_CSNEG I_EXTR I_FCCMP I_FCCMPE 
*     I_FCSEL I_FMADD I_FMSUB I_FNMADD I_FNMSUB I_MADD I_MSUB I_SBFM I_SMADDL I_SMSUBL 
*     I_STLXP I_STXP I_SYS I_UBFM I_UMADDL I_UMSUBL 
*  CST1: ISET_ARM64 
*  CST2: FM_CMOV FM_CMP FM_FMA FM_FMS FM_HW FM_MOV FM_SET FM_STORE 
*  CST3: A_NA A_SETFLAGS 
*  CST4: S_SCALAR 
*  CST5: T_BIT T_FP T_INT T_UINT T_UNDEF 
*  CST6: T_BIT T_FP T_INT T_SINT T_UINT T_UNDEF 
*  CST7: DATASZ_32b DATASZ_64b DATASZ_UNDEF 
*  CST8: DATASZ_32b DATASZ_64b DATASZ_UNDEF 
*  CST9: DATASZ_32b DATASZ_64b DATASZ_UNDEF 
* Used in: template 
*/

#define INSN_OPCODE_4b00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,MCR3,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_ELEMENT_INFO(OUT,(size_t)U_##CST10,CST5,CST6,CST7,CST8);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   if (CST0 != I_CCMN && CST0 != I_CCMP && CST0 != I_CSEL && CST0 != I_CSINC && CST0 != I_CSINV\
      && CST0 != I_CSNEG)\
      insn_add_oprnd(OUT, MCR3);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   DBGMSG("INSN_OPCODE_4b00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_SIMD_VECTOR 
*  MCR1: OPRN_REGISTER_SIMD_VECTOR 
*  MCR2: OPRN_REGISTER_SIMD_VECTOR 
*  MCR3: OPRN_IMMEDIATE 
*  CST0: I_EXT 
*  CST1: ISET_ARM64 
*  CST2: FM_MOV 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_8b 
*  CST8: DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_64b 
*  CST10: RW16B RW8B 
* Used in: template 
*/

//TODO ADD handling of extend to shift switch when there is a stack register in the other operands !
/* 
   if (extend && arm64_extend_get_type(extend) == UXTW){\
      arm64_oprnd_ext_set_shift(ext, arm64_shift_new(LSL, arm64_extend_get_value(extend)));\
   }\
 */
#define INSN_OPCODE_5a00(OUT,VARIANT_ID,MCR0,MCR1,MCR2,MCR3,MCR4,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   insn_set_read_size(OUT,CST9);\
   insn_add_oprnd(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_add_oprnd(OUT, MCR2);\
   insn_add_oprnd(OUT, MCR3);\
   insn_add_oprnd(OUT, MCR4);\
   DBGMSG("INSN_OPCODE_5a00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_IMMEDIATE OPRN_REGISTER_DWORD_OR_ZERO 
*  MCR1: OPRN_IMMEDIATE OPRN_IMMEDIATE_SYSTEM 
*  MCR2: OPRN_IMMEDIATE_SYSTEM 
*  MCR3: OPRN_IMMEDIATE OPRN_IMMEDIATE_SYSTEM 
*  MCR4: OPRN_IMMEDIATE OPRN_REGISTER_DWORD_OR_ZERO 
*  CST0: I_SYS I_SYSL 
*  CST1: ISET_ARM64 
*  CST2: FM_HW 
*  CST3: A_NA 
*  CST4: S_SCALAR 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_UNDEF 
*  CST8: DATASZ_UNDEF 
* Used in: template 
*/

#define INSN_OPCODE_LIST_FIRST_2b00(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   U_INSN_ADD_MULTIPLE_OPRND(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, (size_t)U_##CST10, CST9);\
   DBGMSG("INSN_OPCODE_LIST_FIRST_2b00: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_LIST_FOUR_INDEXED_VECTOR OPRN_REGISTER_LIST_FOUR_VECTOR OPRN_REGISTER_LIST_ONE_INDEXED_VECTOR OPRN_REGISTER_LIST_THREE_INDEXED_VECTOR OPRN_REGISTER_LIST_THREE_VECTOR OPRN_REGISTER_LIST_TWO_INDEXED_VECTOR OPRN_REGISTER_LIST_TWO_VECTOR 
*  MCR1: OPRN_MEMORY OPRN_MEMORY_DWORD_REGISTER_POST_INDEX OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX 
*  CST0: I_LD1 I_LD2 I_LD3 I_LD4 I_ST1 I_ST2 I_ST3 I_ST4 
*  CST1: ISET_ARM64 
*  CST2: FM_LOAD FM_STORE 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_128b DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST10: RW2D W2D WB WD WH WS 
* Used in: template 
*/

#define INSN_OPCODE_LIST_FIRST_2b01(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   insn_set_output_element_type(OUT,CST5);\
   insn_set_input_element_type(OUT,CST6);\
   insn_set_output_element_size(OUT,CST7);\
   insn_set_input_element_size(OUT,CST8);\
   U_INSN_ADD_MULTIPLE_OPRND(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_TOK_VAL(TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_LIST_FIRST_2b01: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_LIST_FOUR_VECTOR OPRN_REGISTER_LIST_ONE_VECTOR OPRN_REGISTER_LIST_THREE_VECTOR OPRN_REGISTER_LIST_TWO_VECTOR 
*  MCR1: OPRN_MEMORY OPRN_MEMORY_DWORD_REGISTER_POST_INDEX OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX 
*  CST0: I_LD1R I_LD2 I_LD2R I_LD3 I_LD3R I_LD4 I_LD4R 
*  CST1: ISET_ARM64 
*  CST2: FM_LOAD 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST8: DATASZ_16b DATASZ_32b DATASZ_64b DATASZ_8b 
*  CST9: DATASZ_VAR 
*  CST10: W1Dto2D W2Sto4S W4Hto8H W8Bto16B 
*  TOK0: Q 
* Used in: template 
*/

#define INSN_OPCODE_LIST_FIRST_2b02(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,TOK0,TOK1){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_TOKS_SVAL(TOK0, TOK1)],CST5,CST6,CST7,CST8);\
   U_INSN_ADD_MULTIPLE_OPRND(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_TOKS_SVAL(TOK0, TOK1)], CST9);\
   DBGMSG("INSN_OPCODE_LIST_FIRST_2b02: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_LIST_FOUR_VECTOR OPRN_REGISTER_LIST_ONE_VECTOR OPRN_REGISTER_LIST_THREE_VECTOR OPRN_REGISTER_LIST_TWO_VECTOR 
*  MCR1: OPRN_MEMORY OPRN_MEMORY_DWORD_REGISTER_POST_INDEX OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX 
*  CST0: I_LD1 I_LD1R I_LD2R I_LD3R I_LD4R I_ST1 
*  CST1: ISET_ARM64 
*  CST2: FM_LOAD FM_STORE 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_VAR 
*  CST8: DATASZ_VAR 
*  CST9: DATASZ_VAR 
*  CST10: W8Bto2D 
*  TOK0: SZ 
*  TOK1: Q 
* Used in: template 
*/

#define INSN_OPCODE_LIST_FIRST_2b11(OUT,VARIANT_ID,MCR0,MCR1,CST0,CST1,CST2,CST3,CST4,CST5,CST6,CST7,CST8,CST9,CST10,VAR0,TOK0){\
   OUT = insn_new(&arm64_arch);\
   insn_set_opcode(OUT, CST0);\
   insn_set_variant_id(OUT, VARIANT_ID);\
   insn_set_annotate(OUT, CST3);\
   U_SET_ELEMENT_INFO(OUT,variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)],CST5,CST6,CST7,CST8);\
   U_INSN_ADD_MULTIPLE_OPRND(OUT, MCR0);\
   insn_add_oprnd(OUT, MCR1);\
   insn_set_oprnds_arrangements(OUT, variable_suffixes[U_##CST10][U_APPEND_VARTOK(*(size_t*)VAR0, TOK0)], CST9);\
   DBGMSG("INSN_OPCODE_LIST_FIRST_2b11: Reached opcode %d (%s, added to new instructin %p)\n", CST0, #CST0, OUT);\
}
/* 
* Possible arguments:
*  MCR0: OPRN_REGISTER_LIST_FOUR_VECTOR OPRN_REGISTER_LIST_THREE_VECTOR OPRN_REGISTER_LIST_TWO_VECTOR 
*  MCR1: OPRN_MEMORY OPRN_MEMORY_DWORD_REGISTER_POST_INDEX OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX 
*  CST0: I_ST2 I_ST3 I_ST4 
*  CST1: ISET_ARM64 
*  CST2: FM_STORE 
*  CST3: A_NA 
*  CST4: S_SIMD 
*  CST5: T_UNDEF 
*  CST6: T_UNDEF 
*  CST7: DATASZ_VAR 
*  CST8: DATASZ_VAR 
*  CST9: DATASZ_VAR 
*  CST10: RW8Bto4S 
*  VAR0: AS 
*  TOK0: Q 
* Used in: template 
*/

#define OPRN_IMMEDIATE_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_imm(U_TOK_VAL(TOK0));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_IMMEDIATE_0201: Found an immediate operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_12b DATASZ_16b DATASZ_3b DATASZ_4b DATASZ_5b DATASZ_6b DATASZ_7b 
*	CST1: READ 
*	TOK0: IMM12 IMM16 IMM3 IMM3_2 IMM4 IMM5 IMM5_2 IMM6 IMM6_2 IMM7 
*		RT 
*/

#define OPRN_IMMEDIATE_0300(OUT,CST0,CST1,CST2){\
   OUT = oprnd_new_imm(U_##CST2);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_IMMEDIATE_0300: Found an immediate operand (%d)\n", U_##CST2);\
}
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: READ 
*  CST2: EIGHT SIXTEEN THIRTYTWO ZERO 
*/

#define OPRN_IMMEDIATE_1200(OUT,MCR0,CST0,CST1){\
   size_t imm = MCR0;\
   OUT = oprnd_new_imm(imm);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_IMMEDIATE_1200: Found an immediate operand (%zu)\n", imm);\
}
/* 
* Possible arguments:
*	MCR0: CONCATENATE 
*	CST0: DATASZ_12b DATASZ_13b DATASZ_5b 
*	CST1: READ 
*/

#define OPRN_IMMEDIATE_1201(OUT,MCR0,CST0,CST1,TOK0){\
   OUT = oprnd_new_imm(U_TOK_VAL(TOK0));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_set_ext(OUT, MCR0);\
   DBGMSG("OPRN_IMMEDIATE_1201: Found an immediate operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  MCR0: EXTEND SHIFT 
*  CST0: DATASZ_12b DATASZ_16b 
*  CST1: READ 
*  TOK0: IMM12 IMM16 
*/

#define OPRN_IMMEDIATE_2200(OUT,MCR0,MCR1,CST0,CST1){\
   size_t imm = MCR0;\
   OUT = oprnd_new_imm(imm);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_set_ext(OUT, MCR1);\
   DBGMSG("OPRN_IMMEDIATE_2200: Found an immediate operand (%ld)\n", imm);\
}
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  MCR1: EXTEND SHIFT 
*  CST0: DATASZ_8b 
*  CST1: READ 
*/

#define OPRN_IMMEDIATE_SYSTEM_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_imm(U_TOK_VAL(TOK0));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_IMMEDIATE_SYSTEM_0201: Found an system operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_4b 
*	CST1: READ 
*	TOK0: CRM CRN 
*/

#define OPRN_MEMORY_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, 0);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_MEMORY_0201: Found a memory operand with a base register only (%ld).\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*/

#define OPRN_MEMORY_DWORD_REGISTER_INDEX_0202(OUT,CST0,CST1,TOK0,TOK1){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), reg_new(U_TOK_VAL(TOK1), STDQUAD, &arm64_arch), 0, 0);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_MEMORY_DWORD_REGISTER_INDEX_0202: Found a memory operand with a base register (%ld) and a doubleword index register (%ld).\n", U_TOK_VAL(TOK0), U_TOK_VAL(TOK1));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_32b 
*	CST1: READ 
*	TOK0: RN 
*	TOK1: RM 
*/

#define OPRN_MEMORY_DWORD_REGISTER_INDEX_1202(OUT,MCR0,CST0,CST1,TOK0,TOK1){\
   arm64_oprnd_ext_t* ext = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), reg_new(U_TOK_VAL(TOK1), STDQUAD, &arm64_arch), 0, 0);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_set_ext(OUT, ext);\
   DBGMSG("OPRN_MEMORY_DWORD_REGISTER_INDEX_1202: Found a memory operand with a base register (%ld) and a doubleword index register (%ld).\n", U_TOK_VAL(TOK0), U_TOK_VAL(TOK1));\
}
/* 
* Possible arguments:
*	MCR0: EXTEND 
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*	TOK1: RM 
*/

#define OPRN_MEMORY_DWORD_REGISTER_POST_INDEX_0211(OUT,CST0,CST1,VAR0,TOK0){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), reg_new(*(size_t*)VAR0, STDQUAD, &arm64_arch), 0, 0);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_piflag(OUT);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_DWORD_REGISTER_POST_INDEX_0211: Found a memory operand with a base register (%ld) and a doubleword index register (%ld).\n", U_TOK_VAL(TOK0), *(size_t*)VAR0);\
}
/* 
* Possible arguments:
*  CST0: DATASZ_32b 
*  CST1: READ WRITE 
*  VAR0: RMns 
*  TOK0: RN 
*/

#define OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_0202(OUT,CST0,CST1,TOK0,TOK1){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, U_TOK_SVAL(TOK1));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_0202: Found a memory operand with a base register (%ld) and a signed immediate index (%ld).\n", U_TOK_VAL(TOK0), U_TOK_SVAL(TOK1));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*	TOK1: IMM9 
*/

#define OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_1201(OUT,MCR0,CST0,CST1,TOK0){\
   size_t offset = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, offset);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_1201: Found a memory operand with a base register (%ld) and a signed immediate index (%zu).\n", U_TOK_VAL(TOK0), offset);\
}
/* 
* Possible arguments:
*	MCR0: LEFT_SHIFT 
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*/

#define OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_WRITEBACK_0202(OUT,CST0,CST1,TOK0,TOK1){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, U_TOK_SVAL(TOK1));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_WRITEBACK_0202: Found a memory operand with a base register (%ld) and a signed immediate index (%ld)\
      write back in the base register.\n", U_TOK_VAL(TOK0), U_TOK_SVAL(TOK1));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*	TOK1: IMM9 
*/

#define OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_WRITEBACK_1201(OUT,MCR0,CST0,CST1,TOK0){\
   size_t offset = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, offset);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_SIGNED_IMMEDIATE_INDEX_WRITEBACK_1201: Found a memory operand with a base register (%ld) and a signed immediate index (%zu)\
      write back in the base register.\n", U_TOK_VAL(TOK0), offset);\
}
/* 
* Possible arguments:
*	MCR0: LEFT_SHIFT 
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*/

#define OPRN_MEMORY_SIGNED_IMMEDIATE_POST_INDEX_0202(OUT,CST0,CST1,TOK0,TOK1){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, U_TOK_SVAL(TOK1));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_piflag(OUT);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_SIGNED_IMMEDIATE_POST_INDEX_0202: Found a memory operand with a base register (%ld) and a signed post-indexed immediate index (%ld)\
      write back in the base register.\n", U_TOK_VAL(TOK0), U_TOK_SVAL(TOK1));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*	TOK1: IMM9 
*/

#define OPRN_MEMORY_SIGNED_IMMEDIATE_POST_INDEX_1201(OUT,MCR0,CST0,CST1,TOK0){\
   size_t offset = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, offset);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_piflag(OUT);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_SIGNED_IMMEDIATE_POST_INDEX_1201: Found a memory operand with a base register (%ld) and a signed post-indexed immediate index (%zu)\
      write back in the base register.\n", U_TOK_VAL(TOK0), offset);\
}
/* 
* Possible arguments:
*	MCR0: LEFT_SHIFT 
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*/

#define OPRN_MEMORY_SWORD_REGISTER_INDEX_1202(OUT,MCR0,CST0,CST1,TOK0,TOK1){\
   arm64_oprnd_ext_t* ext = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), reg_new(U_TOK_VAL(TOK1), STDQUAD, &arm64_arch), 0, 0);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_set_ext(OUT, ext);\
   DBGMSG("OPRN_MEMORY_SWORD_REGISTER_INDEX_1202: Found a memory operand with a base register (%ld) and a register index (%ld)\
      write back in the base register.\n", U_TOK_VAL(TOK0), U_TOK_VAL(TOK1));\
}
/* 
* Possible arguments:
*	MCR0: EXTEND 
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*	TOK1: RM 
*/

#define OPRN_MEMORY_UNSIGNED_IMMEDIATE_INDEX_0202(OUT,CST0,CST1,TOK0,TOK1){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, U_TOK_VAL(TOK1));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_MEMORY_UNSIGNED_IMMEDIATE_INDEX_0202: Found a memory operand with a base register (%ld) and an unsigned immediate index (%ld).\n", U_TOK_VAL(TOK0), U_TOK_VAL(TOK1));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*	TOK1: IMM12 
*/

#define OPRN_MEMORY_UNSIGNED_IMMEDIATE_INDEX_1201(OUT,MCR0,CST0,CST1,TOK0){\
   size_t offset = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, offset);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_MEMORY_UNSIGNED_IMMEDIATE_INDEX_1201: Found a memory operand with a base register (%ld) and an unsigned immediate index (%zu).\n", U_TOK_VAL(TOK0), offset);\
}
/* 
* Possible arguments:
*	MCR0: LEFT_SHIFT 
*	CST0: DATASZ_32b 
*	CST1: READ WRITE 
*	TOK0: RN 
*/

#define OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX_0301(OUT,CST0,CST1,CST2,TOK0){\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, U_##CST2);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_piflag(OUT);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX_0301: Found a memory operand with a base register (%ld) and an unsigned immediate index (%d).\n", U_TOK_VAL(TOK0), U_##CST2);\
}
/* 
* Possible arguments:
*  CST0: DATASZ_32b 
*  CST1: READ WRITE 
*  CST2: CI1 CI12 CI16 CI2 CI24 CI3 CI32 CI4 CI48 CI6 
*     CI64 CI8 
*  TOK0: RN 
*/


#define OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX_1201(OUT,MCR0,CST0,CST1,TOK0){\
   size_t offset = MCR0;\
   OUT = oprnd_new_mem(NULL, reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch), NULL, 0, offset);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_mem_set_piflag(OUT);\
   oprnd_mem_set_wbflag(OUT);\
   DBGMSG("OPRN_MEMORY_UNSIGNED_IMMEDIATE_POST_INDEX_1201: Found a memory operand with a base register (%ld) and an unsigned immediate index (%zu).\n", U_TOK_VAL(TOK0), offset);\
}
/* 
* Possible arguments:
*  MCR0: ADDITION 
*  CST0: DATASZ_32b 
*  CST1: READ WRITE 
*  TOK0: RN 
*/

#define OPRN_POINTER_1200(OUT,MCR0,CST0,CST1){\
   size_t offset = MCR0;\
   OUT = oprnd_new_ptr(0, offset, POINTER_RELATIVE);\
   oprnd_set_bitsize(OUT,CST0);\
   oprnd_set_role(OUT,U_##CST1);\
   DBGMSG("OPRN_POINTER_1200: Found a pointer operand with an offset of %zu.\n", offset);\
}
/* 
* Possible arguments:
*	MCR0: CONCATENATE LEFT_SHIFT SIGNED_LEFT_SHIFT 
*	CST0: DATASZ_14b DATASZ_21b DATASZ_28b 
*	CST1: READ 
*/

//TODO HANDLE STACK REGISTER
#define OPRN_REGISTER_DWORD_OR_STACK_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_DWORD_OR_STACK_0201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_DWORD 
*	CST1: READ WRITE 
*	TOK0: RD RN 
*/

#define OPRN_REGISTER_DWORD_OR_ZERO_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_DWORD_OR_ZERO_0201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_DWORD 
*	CST1: READ WRITE 
*	TOK0: RA RD RM RN RT RT2 
*/

#define OPRN_REGISTER_DWORD_OR_ZERO_0210(OUT,CST0,CST1,VAR0){\
   OUT = oprnd_new_reg(reg_new(*(size_t*)VAR0, STDQUAD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_DWORD_OR_ZERO_0210: Found a register operand (%zu)\n", *(size_t*)VAR0);\
}
/* 
* Possible arguments:
*	CST0: DATASZ_DWORD 
*	CST1: READ 
*	VAR0: RNn2l RTnl 
*/

#define OPRN_REGISTER_DWORD_OR_ZERO_1201(OUT,MCR0,CST0,CST1,TOK0){\
   arm64_oprnd_ext_t* ext = MCR0;\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), STDQUAD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_set_ext(OUT, ext);\
   DBGMSG("OPRN_REGISTER_DWORD_OR_ZERO_1201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	MCR0: EXTEND REGISTER_SHIFT 
*	CST0: DATASZ_DWORD 
*	CST1: READ 
*	TOK0: RM 
*/

#define OPRN_REGISTER_INDEXED_SIMD_VECTOR_0202(OUT,CST0,CST1,TOK0,TOK1){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), VECT, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_reg_set_irflag(OUT);\
   oprnd_reg_set_index(OUT,U_TOK_VAL(TOK1));\
   DBGMSG("OPRN_REGISTER_INDEXED_SIMD_VECTOR_0202: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RD RM RN 
*  TOK1: IDX1 IMM1 IMM1_2 IMM2 IMM2_2 IMM3 IMM3_2 IMM4 IMM4_2 Q 
*     
*/

#define OPRN_REGISTER_INDEXED_SIMD_VECTOR_0301(OUT,CST0,CST1,CST2,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), VECT, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_reg_set_irflag(OUT);\
   oprnd_reg_set_index(OUT,1);\
   DBGMSG("OPRN_REGISTER_INDEXED_SIMD_VECTOR_0301: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  CST2: C1 
*  TOK0: RD RN 
*/

#define OPRN_REGISTER_INDEXED_SIMD_VECTOR_1201(OUT,MCR0,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), VECT, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_reg_set_irflag(OUT);\
   oprnd_reg_set_index(OUT,(uint64_t)MCR0);\
   DBGMSG("OPRN_REGISTER_INDEXED_SIMD_VECTOR_1201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  CST0: DATASZ_QWORD 
*  CST1: READ 
*  TOK0: RM RN Rm 
*/

#define OPRN_REGISTER_LIST_FOUR_INDEXED_VECTOR_0202(OUT,CST0,CST1,TOK0,TOK1){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 4;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,U_TOK_VAL(TOK1));\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_FOUR_INDEXED_VECTOR_0202: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*  TOK1: Q 
*/

#define OPRN_REGISTER_LIST_FOUR_INDEXED_VECTOR_1201(OUT,MCR0,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 4;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,(uint64_t)MCR0);\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_FOUR_INDEXED_VECTOR_1201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*/

#define OPRN_REGISTER_LIST_FOUR_VECTOR_0201(OUT,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 4;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_FOUR_VECTOR_0201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RN RT 
*/

#define OPRN_REGISTER_LIST_ONE_INDEXED_VECTOR_0202(OUT,CST0,CST1,TOK0,TOK1){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 1;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,U_TOK_VAL(TOK1));\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_ONE_INDEXED_VECTOR_0202: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*  TOK1: Q 
*/

#define OPRN_REGISTER_LIST_ONE_INDEXED_VECTOR_1201(OUT,MCR0,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 1;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,(uint64_t)MCR0);\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_ONE_INDEXED_VECTOR_1201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*/

#define OPRN_REGISTER_LIST_ONE_VECTOR_0201(OUT,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 1;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_ONE_VECTOR_0201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RN RT 
*/

#define OPRN_REGISTER_LIST_THREE_INDEXED_VECTOR_0202(OUT,CST0,CST1,TOK0,TOK1){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 3;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,U_TOK_VAL(TOK1));\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_THREE_INDEXED_VECTOR_0202: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*  TOK1: Q 
*/

#define OPRN_REGISTER_LIST_THREE_INDEXED_VECTOR_1201(OUT,MCR0,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 3;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,(uint64_t)MCR0);\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_THREE_INDEXED_VECTOR_1201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*/

#define OPRN_REGISTER_LIST_THREE_VECTOR_0201(OUT,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 3;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_THREE_VECTOR_0201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RN RT 
*/

#define OPRN_REGISTER_LIST_TWO_INDEXED_VECTOR_0202(OUT,CST0,CST1,TOK0,TOK1){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 2;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,U_TOK_VAL(TOK1));\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_TWO_INDEXED_VECTOR_0202: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*  TOK1: Q 
*/

#define OPRN_REGISTER_LIST_TWO_INDEXED_VECTOR_1201(OUT,MCR0,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 2;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
      oprnd_reg_set_irflag(OUT);\
      oprnd_reg_set_index(OUT,(uint64_t)MCR0);\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_THREE_INDEXED_VECTOR_1201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  MCR0: CONCATENATE 
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RT 
*/

#define OPRN_REGISTER_LIST_TWO_VECTOR_0201(OUT,CST0,CST1,TOK0){\
   int i = U_TOK_VAL(TOK0); int nb_oprnd = 2;\
   oprnd_t** oprnds = (oprnd_t**) lc_malloc0(sizeof(oprnd_t*)*U_MAX_LIST_OPRND);\
   while (nb_oprnd > 0){\
      int index = U_MAX_LIST_OPRND - nb_oprnd;\
      oprnds[index] = oprnd_new_reg(reg_new(i, VECT, &arm64_arch));\
      oprnd_set_bitsize(oprnds[index],CST0);\
      oprnd_set_role(oprnds[index],U_##CST1);\
      nb_oprnd --; i = (i + 1) % 32;\
   }\
   OUT = (void*)oprnds;\
   DBGMSG("OPRN_REGISTER_LIST_TWO_VECTOR_0201: Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ WRITE 
*  TOK0: RN RT 
*/

#define OPRN_REGISTER_SIMD_SCALAR_BYTE_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), BYTE, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SIMD_SCALAR_BYTE_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_BYTE 
*  CST1: READ READ_WRITE WRITE 
*  TOK0: RD RM RN RT 
*/

#define OPRN_REGISTER_SIMD_SCALAR_DWORD_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), DWORD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SIMD_SCALAR_DWORD_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_DWORD 
*  CST1: READ READ_WRITE WRITE 
*  TOK0: RA RD RM RN RT RT2 
*/

#define OPRN_REGISTER_SIMD_SCALAR_HWORD_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), HALF, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SIMD_SCALAR_HWORD_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_HWORD 
*  CST1: READ READ_WRITE WRITE 
*  TOK0: RD RM RN RT 
*/

#define OPRN_REGISTER_SIMD_SCALAR_QWORD_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), QWORD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SIMD_SCALAR_QWORD_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ READ_WRITE WRITE 
*  TOK0: RD RN RT RT2 
*/

#define OPRN_REGISTER_SIMD_SCALAR_SWORD_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), WORD, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SIMD_SCALAR_SWORD_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_SWORD 
*  CST1: READ READ_WRITE WRITE 
*  TOK0: RA RD RM RN RT RT2 
*/

#define OPRN_REGISTER_SIMD_VECTOR_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), VECT, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SIMD_VECTOR_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*  CST0: DATASZ_QWORD 
*  CST1: READ READ_WRITE WRITE 
*  TOK0: RD RM RN 
*/

//TODO HANDLE STACK REGISTER
#define OPRN_REGISTER_SWORD_OR_STACK_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), STDLONG, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SWORD_OR_STACK_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_SWORD 
*	CST1: READ WRITE 
*	TOK0: RD RN 
*/

#define OPRN_REGISTER_SWORD_OR_ZERO_0201(OUT,CST0,CST1,TOK0){\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), STDLONG, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SWORD_OR_ZERO_0201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	CST0: DATASZ_SWORD 
*	CST1: READ WRITE 
*	TOK0: RA RD RM RN RS RT RT2 
*/

#define OPRN_REGISTER_SWORD_OR_ZERO_1201(OUT,MCR0,CST0,CST1,TOK0){\
   arm64_oprnd_ext_t* ext = MCR0;\
   DBGMSG("EXT: %s\n", (arm64_oprnd_ext_get_extend(ext) != NULL) ? "extend" : "shift");\
   DBGMSG("EXTEND: %d, %d\n", arm64_extend_get_type(arm64_oprnd_ext_get_extend(ext)), arm64_extend_get_value(arm64_oprnd_ext_get_extend(ext)));\
   OUT = oprnd_new_reg(reg_new(U_TOK_VAL(TOK0), STDLONG, &arm64_arch));\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   oprnd_set_ext(OUT, ext);\
   DBGMSG("OPRN_REGISTER_SWORD_OR_ZERO_1201 : Found a register operand (%ld)\n", U_TOK_VAL(TOK0));\
}
/* 
* Possible arguments:
*	MCR0: EXTEND REGISTER_SHIFT 
*	CST0: DATASZ_SWORD 
*	CST1: READ 
*	TOK0: RM 
*/

//TODO HANDLE SYSTEM REGISTERS
#define OPRN_REGISTER_SYSTEM_0300(OUT,CST0,CST1,CST2){\
   OUT = oprnd_new_imm(0);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SYSTEM_0300: Found an immediate operand (%d)\n", 0);\
}
/* 
* Possible arguments:
*	CST0: DATASZ_DWORD 
*	CST1: WRITE 
*	CST2: DAIFClr DAIFSet SPSel 
*/

//TODO HANDLE SYSTEM REGISTERS
#define OPRN_REGISTER_SYSTEM_1200(OUT,MCR0,CST0,CST1){\
   size_t value = MCR0;\
   OUT = oprnd_new_imm(value);\
   oprnd_set_bitsize(OUT, CST0);\
   oprnd_set_role(OUT, U_##CST1);\
   DBGMSG("OPRN_REGISTER_SYSTEM_1200: Found an immediate operand (%zu)\n", value);\
}
/* 
* Possible arguments:
*	MCR0: CONCATENATE 
*	CST0: DATASZ_DWORD 
*	CST1: READ WRITE 
*/

#define REGISTER_SHIFT_0111(CST0,VAR0,TOK0) arm64_oprnd_ext_new_shift(arm64_shift_new(*(size_t*)VAR0, U_TOK_VAL(TOK0)))
/* 
* Possible arguments:
*	CST0: DATASZ_UNDEF 
*	VAR0: SHFT 
*	TOK0: IMM5 IMM6 
*/

#define SHIFT_0300(CST0,CST1,CST2) arm64_oprnd_ext_new_shift(arm64_shift_new(U_##CST1, U_##CST2))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: LSL 
*  CST2: CI12 
*/

#define SHIFT_1200(MCR0,CST0,CST1) arm64_oprnd_ext_new_shift(arm64_shift_new(U_##CST1, (uint64_t)MCR0))
/* 
* Possible arguments:
*  MCR0: LEFT_SHIFT 
*  CST0: DATASZ_UNDEF 
*  CST1: LSL 
*/

#define EXTEND_0102(CST0,TOK0,TOK1) arm64_oprnd_ext_new_extend(arm64_extend_new(U_TOK_VAL(TOK0), U_TOK_VAL(TOK1)))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  TOK0: EXT 
*  TOK1: IMM3 
*/

#define EXTEND_0110(CST0,VAR0) arm64_oprnd_ext_new_extend(arm64_extend_new(*(size_t*)VAR0, 0))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  VAR0: EXTw 
*/

#define EXTEND_0111(CST0,VAR0,TOK0) arm64_oprnd_ext_new_extend(arm64_extend_new(*(size_t*)VAR0, U_TOK_VAL(TOK0)))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  VAR0: EXTnx EXTw EXTx 
*  TOK0: IMM3 S 
*/

#define EXTEND_0200(CST0,CST1) arm64_oprnd_ext_new_extend(arm64_extend_new(U_##CST1, 0))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: LSL SXTX 
*/

#define EXTEND_0201(CST0,CST1,TOK0)\
   (U_##CST1 == LSL) ?\
      arm64_oprnd_ext_new_shift(arm64_shift_new(U_##CST1, U_TOK_VAL(TOK0)))\
   :\
      arm64_oprnd_ext_new_extend(arm64_extend_new(U_##CST1, U_TOK_VAL(TOK0)))
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: LSL 
*  TOK0: S 
*/

#define EXTEND_0300(CST0,CST1,CST2)\
   (U_##CST1 == LSL) ?\
      arm64_oprnd_ext_new_shift(arm64_shift_new(U_##CST1, U_##CST2))\
   :\
      arm64_oprnd_ext_new_extend(arm64_extend_new(U_##CST1, U_##CST2))\
/* 
* Possible arguments:
*  CST0: DATASZ_UNDEF 
*  CST1: LSL 
*  CST2: CI12 
*/

#define EXTEND_1110(MCR0,CST0,VAR0)\
   arm64_oprnd_ext_new_extend(arm64_extend_new(*(size_t*)VAR0, (size_t)MCR0))\
/* 
* Possible arguments:
*  MCR0: LEFT_FILL LEFT_SHIFT 
*  CST0: DATASZ_UNDEF 
*  VAR0: EXTw 
*/

#define EXTEND_1200(MCR0,CST0,CST1)\
   ((U_##CST1 == LSL) || (U_##CST1 == MSL)) ?\
      arm64_oprnd_ext_new_shift(arm64_shift_new(U_##CST1, (size_t)MCR0))\
   :\
      arm64_oprnd_ext_new_extend(arm64_extend_new(U_##CST1, (size_t)MCR0))\
/* 
* Possible arguments:
*  MCR0: ADDITION LEFT_FILL LEFT_SHIFT 
*  CST0: DATASZ_UNDEF 
*  CST1: LSL MSL 
*/

#endif