/*
   Copyright (C) 2004 - 2018 Université de Versailles Saint-Quentin-en-Yvelines (UVSQ)

   This file is part of MAQAO.

  MAQAO is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
   as published by the Free Software Foundation; either version 3
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

/**
 * \file
 * */

#include <inttypes.h>

#include "libmcore.h"
#include "DwarfLight.h"

typedef struct md_cntext_s {
   arch_t* arch;        // Current architecture
   queue_t* vars;       // List of variables
   int offset;          // Offset to add to variable offsets, needed because
                        // gcc generates mismatch bewteen DWARF and asm
   char unique_regs;    //
} md_cntxt_t;

/*
 * Check in an ADFA value what is the accessed variable
 * \param val an ADFA value to analyze
 * \param md_cntxt context of current analysis
 * \param vars a list of accessed variable. Set to NULL for the first call
 * \param ret used to return values (1 : several variables for the value)
 * \return the accessed variable or NULL
 */
DwarfVar* _check_adfa_val(adfa_val_t* val, md_cntxt_t* md_cntxt, queue_t* vars,
      int* ret)
{
   if (val == NULL || md_cntxt->arch == NULL)
      return NULL;
   char first = FALSE;

   if (vars == NULL) {
      vars = queue_new();
      first = TRUE;
   }

   if (val->is_mem && val->type == ADFA_TYPE_SONS) {
      if (val->data.sons[0]->type == ADFA_TYPE_IMM
            && val->data.sons[1]->type == ADFA_TYPE_REG) {
         // Look for op in vars
         FOREACH_INQUEUE(md_cntxt->vars, it_var)
         {
            DwarfVar* var = GET_DATA_T(DwarfVar*, it_var);
            DwarfMemLoc* loc = dwarf_var_get_location(var);
            int loc_type = dwarf_memloc_get_type(loc);

            if (loc_type == DWARF_BREG || loc_type == DWARF_FBREG) {
               int offset = dwarf_memloc_get_offset(loc);

               if (offset + md_cntxt->offset == val->data.sons[0]->data.imm) {
                  if (offset + md_cntxt->offset
                        == val->data.sons[0]->data.imm) {
                     queue_add_tail(vars, var);
                  }
               }
            } else if (loc_type == DWARF_FBREG_TBRES) {
               int offset = dwarf_memloc_get_offset(loc);
               if (offset + md_cntxt->offset == val->data.sons[0]->data.imm) {
                  if (offset + md_cntxt->offset
                        == val->data.sons[0]->data.imm) {
                     queue_add_tail(vars, var);
                  }
               }
            }
         }
      }
      // The template [REG, IMM] is (normally) not generated by MAQAO so it is not handled
   }
   // If needed, analyze sons to look for a variable
   if (val->type == ADFA_TYPE_SONS) {
      _check_adfa_val(val->data.sons[0], md_cntxt, vars, ret);
      _check_adfa_val(val->data.sons[1], md_cntxt, vars, ret);
   }

   // If it is root element of the value, analyze found variables
   if (first == TRUE) {
      if (queue_length(vars) == 1)
         return (queue_peek_head(vars));
      else if (queue_length(vars) > 1) {
         DwarfVar* accessed_var = NULL;
         int current_pointer = 0;
         FOREACH_INQUEUE(vars, it) {
            DwarfVar* var = GET_DATA_T(DwarfVar*, it);
            int pts = dwarf_var_get_pointer_number(var);
            if (pts > 0 && accessed_var != NULL) {
               //printf ("[[[  Several variables are pointers   ]]]");
               if (ret != NULL)
                  *ret = 1;
               return (NULL);
            } else if (pts > 0) {
               current_pointer = pts;
               accessed_var = var;
            }
         }

         //TODO: current_pointer isn't used
         (void) current_pointer;

         if (accessed_var != NULL)
            return (accessed_var);
      }
   }
   return (NULL);
}

/*
 * Print a variable
 * \param var a variable to print
 * \param f function the variable belongs to
 * \param src a user string
 */
static void print_var(DwarfVar* var, fct_t* f, char* src)
{
   DwarfMemLoc* loc = dwarf_var_get_location(var);
   int loc_type = dwarf_memloc_get_type(loc);
   printf("  %s (%s : %d) %s\n", dwarf_var_get_name(var), src, loc_type,
         dwarf_var_get_full_type(var));

   switch (loc_type) {
   case DWARF_REG: /**< The value is directly in a register*/
   {
      reg_t* reg = dwarf_memloc_get_register(loc);
      printf("    %s\n",
            arch_get_reg_name(f->asmfile->arch, reg->type, reg->name));
      break;
   }
   case DWARF_BREG: /**< The value is at the address contained in reg + offset*/
   case DWARF_FBREG: /**< The value is at the address contained in reg + offset*/
   {
      reg_t* reg = dwarf_memloc_get_register(loc);
      int offset = dwarf_memloc_get_offset(loc);

      if (offset >= 0)
         printf("    %s + 0x%x\n",
               arch_get_reg_name(f->asmfile->arch, reg->type, reg->name),
               offset);
      else
         printf("    %s - 0x%x\n",
               arch_get_reg_name(f->asmfile->arch, reg->type, reg->name),
               -offset);
      break;
   }
   case DWARF_ADDR: /**< The value is at a fixed address*/
      printf("    0x%"PRIx64"\n", dwarf_memloc_get_address(loc));
      break;
   case DWARF_NONE:
      printf("  <location does not exist>\n");
      break;
   case DWARF_FBREG_TBRES:
      if (dwarf_memloc_get_offset(loc) < 0)
         printf("    -0x%x\n", -dwarf_memloc_get_offset(loc));
      else
         printf("    0x%x\n", dwarf_memloc_get_offset(loc));
      break;
   default:
      break;
   }
}

/*
 * Initialize the context used for the analysis
 * \param f current function
 * \param cntxt context of data flow analysiss
 * \return the analysis context
 */
static void* _init(fct_t* f, adfa_cntxt_t* cntxt)
{
   (void) cntxt;
   DwarfFunction* df = (DwarfFunction*) f->debug->data;
   md_cntxt_t* md_cntxt = lc_malloc(sizeof(md_cntxt_t));
   queue_t* params = dwarf_function_get_parameters(df);
   queue_t* variables = dwarf_function_get_local_variables(df);
   md_cntxt->vars = queue_new();
   md_cntxt->arch = f->asmfile->arch;
   md_cntxt->offset = 0;
   md_cntxt->unique_regs = 0;

   int nb_reg = lcore_get_nb_registers(md_cntxt->arch);
   char* tmp = lc_malloc0(nb_reg * sizeof(char));

   // For a mysterious reason, an offset on 0x10 is needed for GNU compilers
   // (at least GCC, check for others)
   if (f->debug->comp_code == COMP_GNU && f->debug->lang_code == LANG_C)
      md_cntxt->offset = 0x10;

   // List and save function parameters whose location is not DWARF_NONE
   FOREACH_INQUEUE(params, it_v1) {
      DwarfVar* var = GET_DATA_T(DwarfVar*, it_v1);
      DwarfMemLoc* loc = dwarf_var_get_location(var);

      if (dwarf_memloc_get_type(loc) != DWARF_NONE) {
         queue_add_tail(md_cntxt->vars, var);
         print_var(var, f, "param");

         if (dwarf_memloc_get_type(loc) != DWARF_BREG
               && dwarf_memloc_get_type(loc) != DWARF_FBREG) {
            md_cntxt->unique_regs = -1;
         } else {
            tmp[__regID(dwarf_memloc_get_register(loc), md_cntxt->arch)]++;
         }
      }
   }

   // List and save function variables whose location is not DWARF_NONE
   FOREACH_INQUEUE(variables, it_v2) {
      DwarfVar* var = GET_DATA_T(DwarfVar*, it_v2);
      DwarfMemLoc* loc = dwarf_var_get_location(var);

      if (dwarf_memloc_get_type(loc) != DWARF_NONE) {
         queue_add_tail(md_cntxt->vars, var);
         print_var(var, f, "variable");

         if (dwarf_memloc_get_type(loc) != DWARF_BREG
               && dwarf_memloc_get_type(loc) != DWARF_FBREG) {
            md_cntxt->unique_regs = -1;
         } else {
            tmp[__regID(dwarf_memloc_get_register(loc), md_cntxt->arch)]++;
         }
      }
   }

   if (md_cntxt->unique_regs == 0) {
      int i = 0;
      for (i = 0; i < nb_reg; i++)
         if (tmp[i] != 0 && tmp[i] != 1)
            md_cntxt->unique_regs = -1;

      if (md_cntxt->unique_regs == 0)
         md_cntxt->unique_regs = 1;
   }

   lc_free(tmp);
   return (md_cntxt);
}

/*
 * Checks if an instruction should be analyzed
 * \param ssain an SSA assembly instruction
 * \param useless not used
 * \return TRUE if the instruction should be analyzed, else FALSE
 */
static int _insn_filter(ssa_insn_t* ssain, void* pmd_cntxt)
{
   md_cntxt_t* md_cntxt = (md_cntxt_t*) pmd_cntxt;
   insn_t* in = ssain->in;
   int i = 0;
   unsigned short family = insn_get_family(in);

   if (queue_length(md_cntxt->vars) == 0)
      return (FALSE);
   if (family == FM_LEA || family == FM_CALL || family == FM_NOP)
      return (FALSE);

   for (i = 0; i < insn_get_nb_oprnds(in); i++) {
      oprnd_t* op = insn_get_oprnd(in, i);
      if (oprnd_is_mem(op))
         return (TRUE);
   }
   return (FALSE);
}

/*
 * Function called for each analyzed instruction
 * \param ssain current instruction
 * \param val computed value
 * \param ht hastbale of computed values indexed by ssa register
 * \param pmd_cntxt pointer on current context
 */
static void _insn_execute_(ssa_insn_t* ssain, adfa_val_t* val, hashtable_t* ht,
      void* pmd_cntxt)
{
   (void) val;
   md_cntxt_t* md_cntxt = (md_cntxt_t*) pmd_cntxt;
   int i = 0;
   insn_t* in = ssain->in;
   for (i = 0; i < insn_get_nb_oprnds(in); i++) {
      oprnd_t* op = insn_get_oprnd(in, i);
      if (oprnd_is_mem(op)) {
         print_SSA_insn(ssain, md_cntxt->arch, stdout);

         // A register and an offset
         if ((oprnd_get_index(op) == NULL)
               || (oprnd_get_base(op) == NULL && oprnd_get_index(op) != NULL
                     && oprnd_get_scale(op) == 1)) {
            char found = FALSE;
            int index = 2 * i;
            if (oprnd_get_index(op) != NULL)
               index++;

            // ----------------------------------------------------------------
            // Look for a variable corresponding to the memory access
            FOREACH_INQUEUE(md_cntxt->vars, it_var) {
               DwarfVar* var = GET_DATA_T(DwarfVar*, it_var);
               DwarfMemLoc* loc = dwarf_var_get_location(var);
               int loc_type = dwarf_memloc_get_type(loc);

               if (loc_type == DWARF_BREG || loc_type == DWARF_FBREG) {
                  reg_t* reg = dwarf_memloc_get_register(loc);
                  int offset = dwarf_memloc_get_offset(loc);

                  if (__regID(reg, md_cntxt->arch)
                        == __regID(ssain->oprnds[index]->reg, md_cntxt->arch)
                        && offset + md_cntxt->offset == oprnd_get_offset(op)) {
                     found = TRUE;
                     printf("   [[%s]]", dwarf_var_get_name(var));
                  } else if (__regID(reg, md_cntxt->arch)
                        == __regID(ssain->oprnds[index]->reg, md_cntxt->arch)
                        && md_cntxt->unique_regs == 1) {
                     found = TRUE;
                     printf("   [[%s]]", dwarf_var_get_name(var));
                  }
               } else if (loc_type == DWARF_FBREG_TBRES) {
                  int offset = dwarf_memloc_get_offset(loc);
                  if (offset + md_cntxt->offset == oprnd_get_offset(op)) {
                     found = TRUE;
                     printf("   [[%s]]", dwarf_var_get_name(var));
                  }
               }
            }

            // ----------------------------------------------------------------
            // Look for a variable corresponding to an element of the register used
            // in the memory address.
            if (found == FALSE) {
               adfa_val_t* dst_val = hashtable_lookup(ht, ssain->oprnds[index]);
               if (dst_val != NULL) {
                  DwarfVar* var = _check_adfa_val(dst_val, md_cntxt, NULL,
                        NULL);
                  printf("   [[%s]]", dwarf_var_get_name(var));
                  if (var != NULL)
                     found = TRUE;
               }
            }
         }
         printf("\n");
      }
   }
}

/*
 * Main function of the analysis
 * \param f a function to analyze
 */
void lcore_memory_debug(fct_t* f)
{
   if (f == NULL || f->debug == NULL)
      return;
   if (f->asmfile->debug->format != DBG_FORMAT_DWARF) {
      ERRMSG("Current debug format in not handled\n");
      return;
   }
   printf("\n%s ---------------\n", fct_get_name(f));

   adfa_driver_t driver;
   driver.init = &_init;
   driver.insn_filter = &_insn_filter;
   driver.insn_execute = &_insn_execute_;
   driver.propagate = NULL;
   driver.user_struct = NULL;
   driver.flags = 0;

   adfa_cntxt_t* cntxt = ADFA_analyze_function(f, &driver);
   ADFA_free(cntxt);
}
